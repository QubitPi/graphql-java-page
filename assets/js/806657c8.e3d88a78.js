"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5922],{5680:(e,a,t)=>{t.d(a,{xA:()=>d,yg:()=>p});var n=t(6540);function r(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function o(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function i(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?o(Object(t),!0).forEach((function(a){r(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function l(e,a){if(null==e)return{};var t,n,r=function(e,a){if(null==e)return{};var t,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)t=o[n],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)t=o[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=n.createContext({}),s=function(e){var a=n.useContext(c),t=a;return e&&(t="function"==typeof e?e(a):i(i({},a),e)),t},d=function(e){var a=s(e.components);return n.createElement(c.Provider,{value:a},e.children)},h={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},u=n.forwardRef((function(e,a){var t=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=s(t),p=r,g=u["".concat(c,".").concat(p)]||u[p]||h[p]||o;return t?n.createElement(g,i(i({ref:a},d),{},{components:t})):n.createElement(g,i({ref:a},d))}));function p(e,a){var t=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=u;var l={};for(var c in a)hasOwnProperty.call(a,c)&&(l[c]=a[c]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var s=2;s<o;s++)i[s]=t[s];return n.createElement.apply(null,i)}return n.createElement.apply(null,t)}u.displayName="MDXCreateElement"},8203:(e,a,t)=>{t.r(a),t.d(a,{contentTitle:()=>c,default:()=>u,frontMatter:()=>l,metadata:()=>s,toc:()=>d});var n=t(8168),r=t(8587),o=(t(6540),t(5680)),i=["components"],l={title:"Batching",date:new Date("2021-08-10T02:52:46.000Z"),description:"How to avoid the dreaded N+1 calls for data and make your graphql system more efficient"},c="Using Dataloader",s={unversionedId:"batching",id:"version-v23/batching",isDocsHomePage:!1,title:"Batching",description:"How to avoid the dreaded N+1 calls for data and make your graphql system more efficient",source:"@site/versioned_docs/version-v23/batching.md",sourceDirName:".",slug:"/batching",permalink:"/documentation/batching",editUrl:"https://github.com/graphql-java/graphql-java-page/edit/master/versioned_docs/version-v23/batching.md",tags:[],version:"v23",frontMatter:{title:"Batching",date:"2021-08-10T02:52:46.000Z",description:"How to avoid the dreaded N+1 calls for data and make your graphql system more efficient"},sidebar:"version-v23/tutorialSidebar",previous:{title:"Getting started",permalink:"/documentation/getting-started"},next:{title:"Concerns",permalink:"/documentation/concerns"}},d=[{value:"Data Loader only works with AsyncExecutionStrategy",id:"data-loader-only-works-with-asyncexecutionstrategy",children:[],level:2},{value:"Per Request Data Loaders",id:"per-request-data-loaders",children:[],level:2},{value:"Async Calls On Your Batch Loader Function Only",id:"async-calls-on-your-batch-loader-function-only",children:[],level:2},{value:"Passing context to your data loader",id:"passing-context-to-your-data-loader",children:[],level:2}],h={toc:d};function u(e){var a=e.components,t=(0,r.A)(e,i);return(0,o.yg)("wrapper",(0,n.A)({},h,t,{components:a,mdxType:"MDXLayout"}),(0,o.yg)("h1",{id:"using-dataloader"},"Using Dataloader"),(0,o.yg)("p",null,"If you are using ",(0,o.yg)("inlineCode",{parentName:"p"},"graphql"),", you are likely to making queries on a graph of data (no surprises there).  However, it's easy\nto implement inefficient code with naive loading of a graph of data."),(0,o.yg)("p",null,"Using ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/graphql-java/java-dataloader"},"java-dataloader")," will help you to make this a more efficient process by both caching and batching requests for that graph of data items.  If ",(0,o.yg)("inlineCode",{parentName:"p"},"dataloader"),"\nhas seen a data item before, it will have cached the value and will return it without having to ask for it again."),(0,o.yg)("p",null,"Imagine we have the StarWars query outlined below.  It asks us to find a hero, and their friend's names, and their friend's friend's\nnames.  It is likely that many of these people will be friends in common."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-graphql"},"{\n  hero {\n    name\n    friends {\n      name\n      friends {\n        name\n      }\n    }\n  }\n}\n")),(0,o.yg)("p",null,"The result of this query is displayed below. You can see that Han, Leia, Luke and R2-D2 are a tight-knit bunch of friends and\nshare many friends in common."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-json"},'{\n  "hero": {\n    "name": "R2-D2",\n    "friends": [\n      {\n        "name": "Luke Skywalker",\n        "friends": [\n          {"name": "Han Solo"},\n          {"name": "Leia Organa"},\n          {"name": "C-3PO"},\n          {"name": "R2-D2"}\n        ]\n      },\n      {\n        "name": "Han Solo",\n        "friends": [\n          {"name": "Luke Skywalker"},\n          {"name": "Leia Organa"},\n          {"name": "R2-D2"}\n        ]\n      },\n      {\n        "name": "Leia Organa",\n        "friends": [\n          {"name": "Luke Skywalker"},\n          {"name": "Han Solo"},\n          {"name": "C-3PO"},\n          {"name": "R2-D2"}\n        ]\n      }\n    ]\n  }\n}\n')),(0,o.yg)("p",null,"A naive implementation would call a ",(0,o.yg)("inlineCode",{parentName:"p"},"DataFetcher")," to retrieve a person object every time it was invoked."),(0,o.yg)("p",null,"In this case it would be ",(0,o.yg)("em",{parentName:"p"},"15")," calls over the network, even though the group of people have a lot of common friends.\nWith ",(0,o.yg)("inlineCode",{parentName:"p"},"dataloader")," you can make the ",(0,o.yg)("inlineCode",{parentName:"p"},"graphql")," query much more efficient."),(0,o.yg)("p",null,"As ",(0,o.yg)("inlineCode",{parentName:"p"},"graphql")," descends each level of the query (e.g., as it processes ",(0,o.yg)("inlineCode",{parentName:"p"},"hero")," and then ",(0,o.yg)("inlineCode",{parentName:"p"},"friends")," and then for each of their ",(0,o.yg)("inlineCode",{parentName:"p"},"friends"),'),\nthe data loader is called to "promise" to deliver a person object.  At each level ',(0,o.yg)("inlineCode",{parentName:"p"},"dataloader.dispatch()")," will be\ncalled to fire off the batch requests for that part of the query. With caching turned on (the default) then\nany previously returned person will be returned as-is for no cost."),(0,o.yg)("p",null,"In the above example there are only ",(0,o.yg)("em",{parentName:"p"},"5")," unique people mentioned but with caching and batching retrieval in place there will be only\n",(0,o.yg)("em",{parentName:"p"},"3")," calls to the batch loader function.  ",(0,o.yg)("em",{parentName:"p"},"3")," calls over the network or to a database is much better than ",(0,o.yg)("em",{parentName:"p"},"15")," calls, you will agree."),(0,o.yg)("p",null,"If you use capabilities like ",(0,o.yg)("inlineCode",{parentName:"p"},"java.util.concurrent.CompletableFuture.supplyAsync()")," then you can make it even more efficient by making the\nremote calls asynchronous to the rest of the query.  This will make it even more timely since multiple calls can happen at once\nif need be."),(0,o.yg)("p",null,"Here is how you might put this in place:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-java"},'//\n// a batch loader function that will be called with N or more keys for batch loading\n// This can be a singleton object since it\'s stateless\n//\nBatchLoader<String, Object> characterBatchLoader = new BatchLoader<String, Object>() {\n    @Override\n    public CompletionStage<List<Object>> load(List<String> keys) {\n        //\n        // we use supplyAsync() of values here for maximum parallelisation\n        //\n        return CompletableFuture.supplyAsync(() -> getCharacterDataViaBatchHTTPApi(keys));\n    }\n};\n\n//\n// use this data loader in the data fetchers associated with characters and put them into\n// the graphql schema (not shown)\n//\nDataFetcher<?> heroDataFetcher = new DataFetcher<Object>() {\n    @Override\n    public Object get(DataFetchingEnvironment environment) {\n        DataLoader<String, Object> dataLoader = environment.getDataLoader("character");\n        return dataLoader.load("2001"); // R2D2\n    }\n};\n\nDataFetcher<?> friendsDataFetcher = new DataFetcher<Object>() {\n    @Override\n    public Object get(DataFetchingEnvironment environment) {\n        StarWarsCharacter starWarsCharacter = environment.getSource();\n        List<String> friendIds = starWarsCharacter.getFriendIds();\n        DataLoader<String, Object> dataLoader = environment.getDataLoader("character");\n        return dataLoader.loadMany(friendIds);\n    }\n};\n\n//\n// this instrumentation implementation will dispatch all the data loaders\n// as each level of the graphql query is executed and hence make batched objects\n// available to the query and the associated DataFetchers\n//\n// In this case we use options to make it keep statistics on the batching efficiency\n//\nDataLoaderDispatcherInstrumentationOptions options = DataLoaderDispatcherInstrumentationOptions\n        .newOptions().includeStatistics(true);\n\nDataLoaderDispatcherInstrumentation dispatcherInstrumentation\n        = new DataLoaderDispatcherInstrumentation(options);\n\n//\n// now build your graphql object and execute queries on it.\n// the data loader will be invoked via the data fetchers on the\n// schema fields\n//\nGraphQL graphQL = GraphQL.newGraphQL(buildSchema())\n        .instrumentation(dispatcherInstrumentation)\n        .build();\n\n//\n// a data loader for characters that points to the character batch loader\n//\n// Since data loaders are stateful, they are created per execution request.\n//\nDataLoader<String, Object> characterDataLoader = DataLoaderFactory.newDataLoader(characterBatchLoader);\n\n//\n// DataLoaderRegistry is a place to register all data loaders in that needs to be dispatched together\n// in this case there is 1 but you can have many.\n//\n// Also note that the data loaders are created per execution request\n//\nDataLoaderRegistry registry = new DataLoaderRegistry();\nregistry.register("character", characterDataLoader);\n\nExecutionInput executionInput = newExecutionInput()\n        .query(getQuery())\n        .dataLoaderRegistry(registry)\n        .build();\n\nExecutionResult executionResult = graphQL.execute(executionInput);\n')),(0,o.yg)("p",null,"In this example we explicitly added the ",(0,o.yg)("inlineCode",{parentName:"p"},"DataLoaderDispatcherInstrumentation")," because we wanted to tweak its options.  However,\nit will be automatically added for you if you don't add it manually."),(0,o.yg)("p",null,"You can read a lot more about the ",(0,o.yg)("inlineCode",{parentName:"p"},"java-dataloader")," API in detail over\nat ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/graphql-java/java-dataloader#readme"},"https://github.com/graphql-java/java-dataloader"),"."),(0,o.yg)("h2",{id:"data-loader-only-works-with-asyncexecutionstrategy"},"Data Loader only works with AsyncExecutionStrategy"),(0,o.yg)("p",null,"The only execution that works with DataLoader is ",(0,o.yg)("inlineCode",{parentName:"p"},"graphql.execution.AsyncExecutionStrategy"),".  This is because this execution strategy knows\nwhen the most optimal time to dispatch() your load calls is.  It does this by deeply tracking how many fields are outstanding and whether they\nare list values and so on."),(0,o.yg)("p",null,"Other execution strategies such as ",(0,o.yg)("inlineCode",{parentName:"p"},"ExecutorServiceExecutionStrategy")," can't do this and hence if the data loader code detects\nyou are not using ",(0,o.yg)("inlineCode",{parentName:"p"},"AsyncExecutionStrategy")," then it will simply dispatch the data loader as each field is encountered.  You\nmay get ",(0,o.yg)("inlineCode",{parentName:"p"},"caching")," of values, but you will not get ",(0,o.yg)("inlineCode",{parentName:"p"},"batching")," of them."),(0,o.yg)("h2",{id:"per-request-data-loaders"},"Per Request Data Loaders"),(0,o.yg)("p",null,"If you are serving web requests then the data can be specific to the user requesting it. If you have user specific data then you will not want to\ncache data meant for user A to then later give it to user B in a subsequent request."),(0,o.yg)("p",null,"The scope of your DataLoader instances is important. You will want to create them per web request to\nensure data is only cached within that web request and no more. It also ensures that a ",(0,o.yg)("inlineCode",{parentName:"p"},"dispatch")," call\nonly affects that graphql execution and no other."),(0,o.yg)("p",null,"DataLoaders by default act as caches.  If they have seen a value before for a key then they will automatically return\nit in order to be efficient.  They cache promises to a value and optionally the value itself."),(0,o.yg)("p",null,"If your data can be shared across web requests then you might want to change the ",(0,o.yg)("inlineCode",{parentName:"p"},"ValueCache")," implementation of your data loaders, so they share\ndata via caching systems like memcached or redis."),(0,o.yg)("p",null,"You still create data loaders per request, however the caching layer will allow data sharing (if that's suitable)."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-java"},"ValueCache<String, Object> crossRequestValueCache = new ValueCache<String, Object>() {\n    @Override\n    public CompletableFuture<Object> get(String key) {\n        return redisIntegration.getValue(key);\n    }\n\n    @Override\n    public CompletableFuture<Object> set(String key, Object value) {\n        return redisIntegration.setValue(key, value);\n    }\n\n    @Override\n    public CompletableFuture<Void> delete(String key) {\n        return redisIntegration.clearKey(key);\n    }\n\n    @Override\n    public CompletableFuture<Void> clear() {\n        return redisIntegration.clearAll();\n    }\n};\n\nDataLoaderOptions options = DataLoaderOptions.newOptions().setValueCache(crossRequestValueCache);\n\nDataLoader<String, Object> dataLoader = DataLoaderFactory.newDataLoader(batchLoader, options);\n")),(0,o.yg)("h2",{id:"async-calls-on-your-batch-loader-function-only"},"Async Calls On Your Batch Loader Function Only"),(0,o.yg)("p",null,"The data loader code pattern works by combining all the outstanding data loader calls into more efficient batch loading calls."),(0,o.yg)("p",null,"graphql-java tracks what outstanding data loader calls have been made, and it is its responsibility to call ",(0,o.yg)("inlineCode",{parentName:"p"},"dispatch"),"\nin the background at the most optimal time, which is when all graphql fields have been examined and dispatched."),(0,o.yg)("p",null,"However, there is a code pattern that will cause your data loader calls to never complete, and these ",(0,o.yg)("em",{parentName:"p"},"MUST")," be avoided.  This bad\npattern consists of making an asynchronous off thread call to a ",(0,o.yg)("inlineCode",{parentName:"p"},"DataLoader")," in your data fetcher."),(0,o.yg)("p",null,"The following will not work (it will never complete)."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-java"},'BatchLoader<String, Object> batchLoader = new BatchLoader<String, Object>() {\n    @Override\n    public CompletionStage<List<Object>> load(List<String> keys) {\n        return CompletableFuture.completedFuture(getTheseCharacters(keys));\n    }\n};\n\nDataLoader<String, Object> characterDataLoader = DataLoaderFactory.newDataLoader(batchLoader);\n\n// .... later in your data fetcher\n\nDataFetcher<?> dataFetcherThatCallsTheDataLoader = new DataFetcher<Object>() {\n    @Override\n    public Object get(DataFetchingEnvironment environment) {\n        //\n        // Don\'t DO THIS!\n        //\n        return CompletableFuture.supplyAsync(() -> {\n            String argId = environment.getArgument("id");\n            DataLoader<String, Object> characterLoader = environment.getDataLoader("characterLoader");\n            return characterLoader.load(argId);\n        });\n    }\n};\n')),(0,o.yg)("p",null,"In the example above, the call to ",(0,o.yg)("inlineCode",{parentName:"p"},"characterDataLoader.load(argId)")," can happen some time in the future on another thread.  The graphql-java\nengine has no way of knowing when it's a good time to dispatch outstanding ",(0,o.yg)("inlineCode",{parentName:"p"},"DataLoader")," calls and hence the data loader call might never complete\nas expected and no results will be returned."),(0,o.yg)("p",null,"Remember a data loader call is just a promise to actually get a value later when it's an optimal time for all outstanding calls to be batched\ntogether.  The most optimal time is when the graphql field tree has been examined and all field values are currently dispatched."),(0,o.yg)("p",null,"The following is how you can still have asynchronous code, by placing it into the ",(0,o.yg)("inlineCode",{parentName:"p"},"BatchLoader")," itself."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-java"},'BatchLoader<String, Object> batchLoader = new BatchLoader<String, Object>() {\n    @Override\n    public CompletionStage<List<Object>> load(List<String> keys) {\n        return CompletableFuture.supplyAsync(() -> getTheseCharacters(keys));\n    }\n};\n\nDataLoader<String, Object> characterDataLoader = DataLoaderFactory.newDataLoader(batchLoader);\n\n// .... later in your data fetcher\n\nDataFetcher<?> dataFetcherThatCallsTheDataLoader = new DataFetcher<Object>() {\n    @Override\n    public Object get(DataFetchingEnvironment environment) {\n        //\n        // This is OK\n        //\n        String argId = environment.getArgument("id");\n        DataLoader<String, Object> characterLoader = environment.getDataLoader("characterLoader");\n        return characterLoader.load(argId);\n    }\n};\n')),(0,o.yg)("p",null,"Notice above the ",(0,o.yg)("inlineCode",{parentName:"p"},"characterDataLoader.load(argId)")," returns immediately.  This will enqueue the call for data until a later time when all\nthe graphql fields are dispatched."),(0,o.yg)("p",null,"Then later when the ",(0,o.yg)("inlineCode",{parentName:"p"},"DataLoader")," is dispatched, its ",(0,o.yg)("inlineCode",{parentName:"p"},"BatchLoader")," function is called.  This code can be asynchronous so that if you have multiple batch loader\nfunctions they all can run at once.  In the code above ",(0,o.yg)("inlineCode",{parentName:"p"},"CompletableFuture.supplyAsync(() -> getTheseCharacters(keys));")," will run the ",(0,o.yg)("inlineCode",{parentName:"p"},"getTheseCharacters"),"\nmethod in another thread."),(0,o.yg)("h2",{id:"passing-context-to-your-data-loader"},"Passing context to your data loader"),(0,o.yg)("p",null,"The data loader library supports two types of context being passed to the batch loader. The first is\nan overall context object per dataloader, and the second is a map of per loaded key context objects."),(0,o.yg)("p",null,"This allows you to pass in the extra details you may need to make downstream calls.  The dataloader key is used\nin the caching of results, but the context objects can be made available to help with the call."),(0,o.yg)("p",null,"So in the example below we have an overall security context object that gives out a call token, and we also pass the graphql source\nobject to each ",(0,o.yg)("inlineCode",{parentName:"p"},"dataLoader.load()")," call."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-java"},'BatchLoaderWithContext<String, Object> batchLoaderWithCtx = new BatchLoaderWithContext<String, Object>() {\n\n    @Override\n    public CompletionStage<List<Object>> load(List<String> keys, BatchLoaderEnvironment loaderContext) {\n        //\n        // we can have an overall context object\n        SecurityContext securityCtx = loaderContext.getContext();\n        //\n        // and we can have a per key set of context objects\n        Map<Object, Object> keysToSourceObjects = loaderContext.getKeyContexts();\n\n        return CompletableFuture.supplyAsync(() -> getTheseCharacters(securityCtx.getToken(), keys, keysToSourceObjects));\n    }\n};\n\n// ....\n\nSecurityContext securityCtx = SecurityContext.newSecurityContext();\n\nBatchLoaderContextProvider contextProvider = new BatchLoaderContextProvider() {\n    @Override\n    public Object getContext() {\n        return securityCtx;\n    }\n};\n//\n// this creates an overall context for the dataloader\n//\nDataLoaderOptions loaderOptions = DataLoaderOptions.newOptions().setBatchLoaderContextProvider(contextProvider);\nDataLoader<String, Object> characterDataLoader = DataLoaderFactory.newDataLoader(batchLoaderWithCtx, loaderOptions);\n\n// .... later in your data fetcher\n\nDataFetcher<?> dataFetcherThatCallsTheDataLoader = new DataFetcher<Object>() {\n    @Override\n    public Object get(DataFetchingEnvironment environment) {\n        String argId = environment.getArgument("id");\n        Object source = environment.getSource();\n        //\n        // you can pass per load call contexts\n        //\n        return characterDataLoader.load(argId, source);\n    }\n};\n')))}u.isMDXComponent=!0}}]);