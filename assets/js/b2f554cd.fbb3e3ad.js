"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1477],{10:function(e){e.exports=JSON.parse('{"blogPosts":[{"id":"v22-released","metadata":{"permalink":"/blog/v22-released","editUrl":"https://github.com/graphql-java/graphql-java-page/edit/master/blog/blog/2024-04-18-v22-released.md","source":"@site/blog/2024-04-18-v22-released.md","title":"Version 22 released","description":"We are thrilled to announce the release of graphql-java v22.0! Thanks to everyone in the community who contributed to the release, whether that was code, helping to report issues, or participating in discussions.","date":"2024-04-18T00:00:00.000Z","formattedDate":"April 18, 2024","tags":[],"readingTime":0.485,"truncated":false,"authors":[{"name":"Donna Zhou","title":"Maintainer of GraphQL Java","url":"https://github.com/dondonz","imageURL":"https://github.com/dondonz.png","key":"donna"}],"nextItem":{"title":"Version 21 released","permalink":"/blog/v21-released"}},"content":"We are thrilled to announce the release of graphql-java v22.0! Thanks to everyone in the community who contributed to the release, whether that was code, helping to report issues, or participating in discussions.\\n\\nThis is a **breaking change** release, which includes major performance improvements. This release also introduces the `@defer` directive, which enables data to be received incrementally, rather than waiting until all data is resolved. This can reduce an application\'s time-to-interactive. See more on the `@defer` draft specification on the [GraphQL Working Group\'s GitHub repo](https://github.com/graphql/graphql-wg/blob/main/rfcs/DeferStream.md).\\n\\nFor the full details, please see the release notes on [GitHub](https://github.com/graphql-java/graphql-java/releases/tag/v22.0)."},{"id":"v21-released","metadata":{"permalink":"/blog/v21-released","editUrl":"https://github.com/graphql-java/graphql-java-page/edit/master/blog/blog/2023-07-11-v21-released.md","source":"@site/blog/2023-07-11-v21-released.md","title":"Version 21 released","description":"We are pleased to announce the release of graphql-java v21.0! Thanks to everyone in the community who contributed to the release, whether that was code, helping to report issues, or participating in discussions.","date":"2023-07-11T00:00:00.000Z","formattedDate":"July 11, 2023","tags":[],"readingTime":0.35,"truncated":false,"authors":[{"name":"Donna Zhou","title":"Maintainer of GraphQL Java","url":"https://github.com/dondonz","imageURL":"https://github.com/dondonz.png","key":"donna"}],"prevItem":{"title":"Version 22 released","permalink":"/blog/v22-released"},"nextItem":{"title":"GraphQL Java release policy","permalink":"/blog/release-policy"}},"content":"We are pleased to announce the release of graphql-java v21.0! Thanks to everyone in the community who contributed to the release, whether that was code, helping to report issues, or participating in discussions.\\n\\nAnd a very Happy 8th Birthday to graphql-java, who celebrated their birthday last week!\\n\\nThis is a **breaking change** release, including upgrading to Java 11 and changes to `parseValue` coercion. See the full release notes on [GitHub](https://github.com/graphql-java/graphql-java/releases/tag/v21.0)."},{"id":"release-policy","metadata":{"permalink":"/blog/release-policy","editUrl":"https://github.com/graphql-java/graphql-java-page/edit/master/blog/blog/2023-03-21-release-policy.md","source":"@site/blog/2023-03-21-release-policy.md","title":"GraphQL Java release policy","description":"We\u2019re formalising our release schedule to give the community a better idea of when to expect releases, what will be contained within them, and when important fixes will be backported.","date":"2023-03-21T00:00:00.000Z","formattedDate":"March 21, 2023","tags":[],"readingTime":1.665,"truncated":false,"authors":[{"name":"Donna Zhou","title":"Maintainer of GraphQL Java","url":"https://github.com/dondonz","imageURL":"https://github.com/dondonz.png","key":"donna"}],"prevItem":{"title":"Version 21 released","permalink":"/blog/v21-released"},"nextItem":{"title":"GraphQL Java will require Java 11","permalink":"/blog/java-11-required"}},"content":"We\u2019re formalising our release schedule to give the community a better idea of when to expect releases, what will be contained within them, and when important fixes will be backported.\\n\\n## General release schedule\\nGoing forward, we plan to have 4 releases every year, approximately one per quarter. We will alternate between releases containing breaking changes, and releases containing features and bugfixes (without breaking changes).\\n\\nFor example: our next release 20.1 will be in late March 2023, and this will be a feature and bugfix release without breaking changes. Therefore, we\u2019re going to retain Java 8 in the 20.1 release. Our subsequent quarterly release will be around early July 2023 and will contain breaking changes, including upgrading to Java 11.\\n\\n## Security backports\\nWe will backport critical bugfixes and security fixes for versions dating back 18 months (or roughly 6 versions). These fixes will be backported depending on severity and demand. As security fixes are time sensitive, we will release them on demand instead of waiting for the next quarterly release date.\\n\\n## Bugfix backports\\nWe will backport important bug fixes at most 12 months (or roughly 4 versions). These fixes will be backported depending on the severity of the bug and demand.\\n\\n## Deprecations\\nWhen code is deprecated, we will wait at least 12 months before removing it (or roughly 4 versions).\\n\\n## Version numbering\\nWe will continue to use `major.minor` version numbering.\\n\\nA minor version can include bug fixes and features, but not breaking changes. A major version can include breaking changes.\\n\\n## Allowing for policy changes\\nThe aim of this release policy to give the community a better indication of release dates, what is contained in releases, and when fixes will be backported. However, we may make a pragmatic decision to diverge from this policy when required. For example, a major and urgent breaking change could result in two breaking change releases in a row. If we diverge from this release policy, we\u2019ll make it clear in the release notes."},{"id":"java-11-required","metadata":{"permalink":"/blog/java-11-required","editUrl":"https://github.com/graphql-java/graphql-java-page/edit/master/blog/blog/2022-12-14-java-11.md","source":"@site/blog/2022-12-14-java-11.md","title":"GraphQL Java will require Java 11","description":"GraphQL Java will require Java 11 as a minimum Java version, starting from version 21.","date":"2022-12-14T00:00:00.000Z","formattedDate":"December 14, 2022","tags":[],"readingTime":0.5,"truncated":false,"authors":[{"name":"Andreas Marek","title":"Maintainer of GraphQL Java","url":"https://github.com/andimarek","imageURL":"https://github.com/andimarek.png","key":"andi"}],"prevItem":{"title":"GraphQL Java release policy","permalink":"/blog/release-policy"},"nextItem":{"title":"Version 20 released","permalink":"/blog/version-20-released"}},"content":"GraphQL Java will require Java 11 as a minimum Java version, starting from version 21.\\n\\nWith Java 8 being released over 8 years ago and Java 17 more than one year ago, we think now is the \\nright time to upgrade the minimum Java version GraphQL Java is developed against.\\n\\nThis means starting with version 21 you need to use at least Java 11 to run GraphQL Java.\\n\\nDepending on the feedback we get, we plan to release bugfix releases for version 20 for some time, but no longer\\nthan until end of 2023.\\n\\nPlease discuss and leave feedback [here](https://github.com/graphql-java/graphql-java/discussions/3052)"},{"id":"version-20-released","metadata":{"permalink":"/blog/version-20-released","editUrl":"https://github.com/graphql-java/graphql-java-page/edit/master/blog/blog/2022-12-07-version-20-released.md","source":"@site/blog/2022-12-07-version-20-released.md","title":"Version 20 released","description":"We are pleased to announce the release of graphql-java 20.0!","date":"2022-12-07T00:00:00.000Z","formattedDate":"December 7, 2022","tags":[],"readingTime":0.44,"truncated":false,"authors":[{"name":"Donna Zhou","title":"Maintainer of GraphQL Java","url":"https://github.com/dondonz","imageURL":"https://github.com/dondonz.png","key":"donna"}],"prevItem":{"title":"GraphQL Java will require Java 11","permalink":"/blog/java-11-required"},"nextItem":{"title":"Spring for GraphQL is the recommended Spring integration","permalink":"/blog/spring-for-graphql"}},"content":"We are pleased to announce the release of graphql-java 20.0!\\n\\nSpecial thanks to each of the 200+ contributors over the years, who have made this milestone possible.\\n\\nWe\'ve added support for record-like property fetching, added performance improvements for `PropertyDataFetcher` and reduced object allocation.\\n\\nVersion 20 also introduces internationalization (i18n) for validation, parsing, and scalar coercion [error messages](https://github.com/graphql-java/graphql-java/tree/master/src/main/resources/i18n). We have added German translations, and we would love to see more languages. If you would like to contribute, please open a pull request.\\n\\nSee the full release notes on [GitHub](https://github.com/graphql-java/graphql-java/releases/tag/v20.0)."},{"id":"spring-for-graphql","metadata":{"permalink":"/blog/spring-for-graphql","editUrl":"https://github.com/graphql-java/graphql-java-page/edit/master/blog/blog/2022-09-20-spring-for-graphql-naming.md","source":"@site/blog/2022-09-20-spring-for-graphql-naming.md","title":"Spring for GraphQL is the recommended Spring integration","description":"If you are building a GraphQL application with Spring, we recommend using the official Spring for GraphQL integration. This integration is a collaboration between the Spring and GraphQL Java teams, and is maintained by the Spring team. In May 2022, Spring for GraphQL 1.0 GA was released.","date":"2022-09-20T00:00:00.000Z","formattedDate":"September 20, 2022","tags":[],"readingTime":0.705,"truncated":false,"authors":[{"name":"Donna Zhou","title":"Maintainer of GraphQL Java","url":"https://github.com/dondonz","imageURL":"https://github.com/dondonz.png","key":"donna"}],"prevItem":{"title":"Version 20 released","permalink":"/blog/version-20-released"},"nextItem":{"title":"GraphQL Java 17 released and an update about LTS","permalink":"/blog/17-released-and-lts"}},"content":"If you are building a GraphQL application with Spring, we recommend using the official [Spring for GraphQL](https://spring.io/projects/spring-graphql) integration. This integration is a collaboration between the Spring and GraphQL Java teams, and is maintained by the Spring team. In May 2022, Spring for GraphQL 1.0 GA was [released](https://spring.io/blog/2022/05/19/spring-for-graphql-1-0-release).\\n\\nUse [Spring Initializr](https://start.spring.io/) to create a GraphQL application. For a quick tutorial, please see our [Spring for GraphQL tutorial](https://www.graphql-java.com/tutorials/getting-started-with-spring-boot).\\n\\nSee also the Spring for GraphQL [documentation](https://docs.spring.io/spring-graphql/docs/current/reference/html/) and the repo on [GitHub](https://github.com/spring-projects/spring-graphql).\\n\\nBefore the official Spring for GraphQL integration was released, there were many other GraphQL integrations for Spring, including the similarly named [GraphQL Java Spring](https://github.com/graphql-java-kickstart/graphql-spring-boot) project from the GraphQL Java team, published under the `com.graphql-java` and `com.graphql-java-kickstart` group IDs. Many tutorials are still referring to this unrelated project.\\n\\nPlease use the official integration named **\\"Spring for GraphQL\\"**, published under `org.springframework` and related group IDs."},{"id":"17-released-and-lts","metadata":{"permalink":"/blog/17-released-and-lts","editUrl":"https://github.com/graphql-java/graphql-java-page/edit/master/blog/blog/2021-08-03-17-released-and-lts.md","source":"@site/blog/2021-08-03-17-released-and-lts.md","title":"GraphQL Java 17 released and an update about LTS","description":"We are happy to announce the availability of GraphQL Java 17.0.","date":"2021-08-03T00:00:00.000Z","formattedDate":"August 3, 2021","tags":[],"readingTime":0.8,"truncated":false,"authors":[{"name":"Andreas Marek","title":"Maintainer of GraphQL Java","url":"https://github.com/andimarek","imageURL":"https://github.com/andimarek.png","key":"andi"}],"prevItem":{"title":"Spring for GraphQL is the recommended Spring integration","permalink":"/blog/spring-for-graphql"},"nextItem":{"title":"GraphQL spec releases are not important","permalink":"/blog/spec-releases-are-not-important"}},"content":"We are happy to announce the availability of GraphQL Java 17.0.\\nSee [17.0 release notes](https://github.com/graphql-java/graphql-java/releases/tag/v17.0) for all the details.\\n\\nAt the same time we wanted to give an update regarding our LTS (Long Term Support) policy.\\nPreviously we maintained a LTS version of 9.x and after quite some time we announced 14.x as the next LTS.\\n\\nThe reality is that we didn\'t maintain 14.x really as a LTS version (we only released one bugfix release).\\nThis was mainly caused by the minimal community feedback and our limited time and resources.\\n\\nGoing forward we decided to no offer any LTS versions anymore. We will only actively maintain and bugfix\\nthe latest version (currently 17). We may backport critical bugfixes, but we are not committed to it.\\n\\nIf this is a huge problem for you or your Company and you are willing to help us with maintaining a LTS\\nversion you can reach us via email at\\nhello at graphql-java dot com."},{"id":"spec-releases-are-not-important","metadata":{"permalink":"/blog/spec-releases-are-not-important","editUrl":"https://github.com/graphql-java/graphql-java-page/edit/master/blog/blog/2021-02-12-spec-releases-are-not-important.md","source":"@site/blog/2021-02-12-spec-releases-are-not-important.md","title":"GraphQL spec releases are not important","description":"Every once in a while somebody asks which version of the GraphQL spec","date":"2021-02-12T00:00:00.000Z","formattedDate":"February 12, 2021","tags":[],"readingTime":1.905,"truncated":false,"authors":[{"name":"Andreas Marek","title":"Maintainer of GraphQL Java","url":"https://github.com/andimarek","imageURL":"https://github.com/andimarek.png","key":"andi"}],"prevItem":{"title":"GraphQL Java 17 released and an update about LTS","permalink":"/blog/17-released-and-lts"},"nextItem":{"title":"GraphQL Java and Threads","permalink":"/blog/threads"}},"content":"Every once in a while somebody asks which version of the [GraphQL spec](https://github.com/graphql/graphql-spec)\\nGraphQL Java supports. The general answer is: the current draft.\\n\\nThe bigger question behind this is: what is the information you want get out of this question?\\nWhy do you ask this question?\\n\\nThe thing is: spec releases are not really important and people misinterpret what they mean.\\n\\n# Evolution of the spec process\\n\\nThe GraphQL spec has five releases so far:\\n\\n- two in 2015 (including the first published version)\\n- two in 2016\\n- one in 2018\\n\\nAs you can see in the first two years spec releases where quite frequently, but after the one in 2018,\\nthere has not been a release.\\n\\n2017 was also the year the [GraphQL Working Group](https://github.com/graphql/graphql-wg) was established.\\nThis group is the main forum to evolve the spec since then. Over time this group established a very high bar\\nfor every PR to be merged into the spec. (See the [Contributing guidelines](https://github.com/graphql/graphql-spec/blob/main/CONTRIBUTING.md))\\n\\nWith this high standard set, nearly all implementations (including GraphQL Java) started to implement every\\nmerged PR instead of waiting for a big release. Because they are very confident this change will be released\\nin this form, it is safe to implement it right away.\\n\\nThis treatment of merged PRs as de-factor releases is now an established rule in the GraphQL community.\\nThis explains why the whole GraphQL ecosystem has evolved a lot since 2018, even without a release.\\n\\n__A release is not needed anymore if every merged PR is like a mini release.__\\n\\nFuture releases are more like an\\n[opportunity to look back and promote the work since the last release.](https://github.com/graphql/graphql-wg/blob/main/notes/2021-02-04.md#promoting-and-documenting-spec-release-5m-brian)\\n\\nI personally hope that we make this de-facto rule, that evey PR is a mini release, more official.\\nWe should not use the word \\"draft\\" any more, but every merged PR should automatically result in a\\nnew GraphQL spec version which is formally approved by the [GraphQL TSC.](https://github.com/graphql/graphql-wg/blob/main/GraphQL-TSC.md)\\n\\nComing back to the question: \\"Which spec version of GraphQL is supported\\"?\\nI hope by now it is clear why this question is probably not really helpful.\\n\\nIt is better to think about certain features you want to discuss instead referring to the spec releases.\\n\\n# Feedback or questions\\nWe use [GitHub Discussions](https://github.com/graphql-java/graphql-java/discussions) for general feedback and questions."},{"id":"threads","metadata":{"permalink":"/blog/threads","editUrl":"https://github.com/graphql-java/graphql-java-page/edit/master/blog/blog/2021-02-05-threads.md","source":"@site/blog/2021-02-05-threads.md","title":"GraphQL Java and Threads","description":"We follow a fundamental rule in GraphQL Java regarding Threads: GraphQL Java never creates","date":"2021-02-05T00:00:00.000Z","formattedDate":"February 5, 2021","tags":[],"readingTime":3.565,"truncated":false,"authors":[{"name":"Andreas Marek","title":"Maintainer of GraphQL Java","url":"https://github.com/andimarek","imageURL":"https://github.com/andimarek.png","key":"andi"}],"prevItem":{"title":"GraphQL spec releases are not important","permalink":"/blog/spec-releases-are-not-important"},"nextItem":{"title":"Building efficient data fetchers by looking ahead","permalink":"/blog/deep-dive-data-fetcher-results"}},"content":"We follow a fundamental rule in GraphQL Java regarding Threads: GraphQL Java never creates\\nThreads or interacts with Thread pools. We do this because we want to give the user the full control\\nand whatever GraphQL Java would do, it would not be correct for every use case.\\n\\nAdditionally to being strictly unopinionated regarding Threads, GraphQL Java is also fully reactive,\\nimplemented via `CompletableFuture` (`CF`).\\nThese two constrain together mean we rely on the `CF` returned by the user.\\nSpecifically we piggyback on the `CF` returned by the `DataFetcher`\\n(or other async methods which can be implemented by the user, but we focus here on `DataFetcher`\\nas it is by far the most important).\\n\\n\\n```java\\n// Pseudo code in GraphQL Java\\n\\nCompletableFuture<Object> dataFetcherResult = invokeDataFetcher();\\ndataFetcherResult.thenApply(result -> {\\n    // in which Thread  where this code happens is controlled by the CF returned\\n    continueExecutingQuery(result);\\n});\\n```\\n\\n# Blocking DataFetcher\\n\\nLets assume you are accessing a DB in a blocking way in your `DataFetcher`:\\n\\n```java\\nString get(DataFetchingEnvironment env) {\\n    return getValueFromDb(env); // blocking the Thread until the value is read from DB\\n};\\n```\\n\\nThis is not completely wrong, but not recommend in general as the consequence of this kind of `DataFecher`\\nis that GraphQL can\'t execute the query in the most efficient way.\\n\\nFor example for the following query:\\n\\n```graphql\\n{\\n  dbData1\\n  dbData2\\n  dbData3\\n}\\n```\\n\\nIf the `DataFetcher` for these `dbData` fields don\'t return a `CF`,\\nbut block the Thread until the data is read, GraphQL Java will not work with maximum efficiency.\\n\\nGraphQL Java can invoke the `DataFetcher` for all three fields in parallel. But if your `DataFetcher` for\\n`dbData1` is blocking, GraphQL Java will also be blocked and only invoke the next `DataFetcher` once `dbData<n>`\\nis finished.\\nThe recommend solution to this problem is offloading your blocking code onto a separate Thread pool\\nas shown here:\\n\\n```java\\nCompletableFuture<String> get(DataFetchingEnvironment env) {\\n    return CompletableFuture.supplyAsync( getValueFromDb(env), dbThreadPool );\\n};\\n```\\n\\nThis code will maximize the performance and will cause all three fields to be fetched in parallel.\\n\\n# Different pools for different work\\n\\nThe subsequent work done by GraphQL Java will be executed in the same `dbThreadPool` until it\\nencounters a new `DataFetcher` returned by the user code and this new `CF` dedicates the Thread\\nfor the subsequent work.\\n\\nIf you want to have separate pools for different kind of work, one for the actual `DataFetcher` which normally\\ninvolve IO and one of the actual GraphQL Java work (which is pure CPU), you need to switch back from your offloaded\\npool to a dedicated GraphQL Java pool before returning the `CF`. You can achieve this with code like this:\\n\\n```java\\nCompletableFuture<String> get(DataFetchingEnvironment env) {\\n    return CompletableFuture.supplyAsync( getValueFromDb(env), dbThreadPool )\\n        .handleAsync((result,exception) -> {\\n            if(exception !=null) throw exception;\\n            return result;\\n        }, graphqlJavaPool);\\n};\\n```\\n\\nNotice the `.handleAsync` which doesn\'t do anything except forwarding the result, but on a\\ndifferent pool (`graphqlJavaPool`).\\n\\nThis way you have different pools for different kind of work (one for CPU bound GraphQL Java work and one\\nfor multiple ones for IO bound work), which can be configured and monitored independently.\\n\\n# In a fully reactive system\\nIf your system is fully reactive your `DataFetcher` will more look like this\\n\\n```java\\nCompletableFuture<String> get(DataFetchingEnvironment env) {\\n    return callAnotherServiceNonBlocking(env); // returns CompletableFuture\\n};\\n```\\n\\nThe code above could be implemented via [Async Http Client](https://github.com/AsyncHttpClient/async-http-client)\\nor [WebFlux WebClient](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-client).\\nBoth provide fully reactive HTTP clients.\\n\\nBecause the code is non blocking there is no need to offload anything on a dedicated Thread pool to avoid blocking\\nGraphQL Java.\\n\\nYou still might want to consider using a dedicated GraphQL Java pool as you otherwise would use\\nThreads which are dedicated to IO. How much this is really relevant depends highly on your use case.\\n\\nFor example `Async Http Client` (`AHC`) uses by default 2 * #cores (this value comes actually from Netty) Threads. If you\\ndon\'t use a dedicated Thread Pool for GraphQL Java you might encounter situations under load where all `AHC`\\nThreads are either busy or blocked by GraphQL Java code and as a result your system is not as performant as it\\ncould be. Normally only load tests in production like environments can show the relevance of different Thread pools.\\n\\n\\n# Feedback or questions\\nWe use [GitHub Discussions](https://github.com/graphql-java/graphql-java/discussions) for general feedback and questions."},{"id":"deep-dive-data-fetcher-results","metadata":{"permalink":"/blog/deep-dive-data-fetcher-results","editUrl":"https://github.com/graphql-java/graphql-java-page/edit/master/blog/blog/2019-04-11-deep-dive-data-fetcher-results.md","source":"@site/blog/2019-04-11-deep-dive-data-fetcher-results.md","title":"Building efficient data fetchers by looking ahead","description":"Today we are looking into the graphql.schema.DataFetchingFieldSelectionSet and graphql.execution.DataFetcherResult objects as means","date":"2019-04-11T00:00:00.000Z","formattedDate":"April 11, 2019","tags":[],"readingTime":4.865,"truncated":false,"authors":[{"name":"Brad Baker","title":"Maintainer of GraphQL Java","url":"https://github.com/bbakerman","imageURL":"https://github.com/bbakerman.png","key":"brad"}],"prevItem":{"title":"GraphQL Java and Threads","permalink":"/blog/threads"},"nextItem":{"title":"GraphQL Deep Dive Part 1 - merged fields","permalink":"/blog/deep-dive-merged-fields"}},"content":"Today we are looking into the `graphql.schema.DataFetchingFieldSelectionSet` and `graphql.execution.DataFetcherResult` objects as means\\nto build efficient data fetchers.\\n\\n# The scenario\\n\\nBut first lets set the scene. Imagine we have a system that can return `issues` and the `comments` on those `issues`\\n\\n```graphql\\n{\\n  issues {\\n    key\\n    summary\\n    comments {\\n        text\\n    }\\n  }\\n}\\n```\\n\\nNominally we would have a `graphql.schema.DataFetcher` on `issues` that returns a list of issues and one on the field `comments` that returns the list of comments\\nfor each issue `source` object.\\n\\nAs you can see this naively creates an *N+1 problem* where we need to fetch data multiple times, one for each `issue` object in isolation.\\n\\nWe could attack this using the `org.dataloader.DataLoader` pattern but there is another way which will discuss in this article.\\n\\n# Look ahead via DataFetchingFieldSelectionSet\\n\\nThe data fetcher behind the `issues` field is able to look ahead and see what sub fields are being asked for.  In this case it knows that `comments` are being asked\\nfor and hence it could prefetch them at the same time.\\n\\n`graphql.schema.DataFetchingEnvironment#getSelectionSet` (aka `graphql.schema.DataFetchingFieldSelectionSet`) can be used by data fetcher code to get the selection set of fields for a given parent field.\\n\\n```java\\nDataFetcher issueDataFetcher = environment -> {\\n    DataFetchingFieldSelectionSet selectionSet = environment.getSelectionSet();\\n    if (selectionSet.contains(\\"comments\\")) {\\n        List<IssueAndCommentsDTO> data = getAllIssuesWithComments(environment, selectionSet.getFields());\\n        return data;\\n    } else {\\n        List<IssueDTO> issues = getAllIssuesWitNoComments(environment);\\n        return issues;\\n    }\\n};\\n```\\n\\nImagine this is backed by an SQL system we might be able to use this field look ahead to produce the following SQL\\n\\n```sql\\nSELECT Issues.Key, Issues.Summary, Comments.Text\\nFROM Issues\\nINNER JOIN Comments ON Issues.CommentID=Comments.ID;\\n```\\n\\nSo we have looked ahead and returned different data depending on the field sub selection.  We have made our system more efficient by using look ahead\\nto fetch data just the `1` time and not `N+1` times.\\n\\n# Code Challenges\\n\\nThe challenge with this code design is that the shapes of the returned data is now field sub selection specific.  We needed a `IssueAndCommentsDTO` for one sub selection\\npath and a simpler `IssueDTO` for another path.\\n\\nWith enough paths this becomes problematic as it adds new DTO classes per path and makes out child data fetchers more complex\\n\\nAlso the standard graphql pattern is that the returned object becomes the `source` ie. `graphql.schema.DataFetchingEnvironment#getSource` of the next child\\ndata fetcher.  But we might have pre fetched data that is needed 2 levels deep and this is challenging to do since each data fetcher would need to capture and copy\\nthat data down to the layers below via new TDOs classes per level.\\n\\n\\n# Passing Data and Local Context\\n\\nGraphQL Java offers a capability that helps with this pattern.  GraphQL Java goes beyond what the reference graphql-js system gives you where the object you\\nreturned is automatically the `source` of the next child fetcher and that\'s all it can be.\\n\\nIn GraphQL Java you can use well known `graphql.execution.DataFetcherResult` to return three sets of values\\n\\n* `data`  - which will be used as the source on the next set of sub fields\\n* `errors` - allowing you to return data as well as errors\\n* `localContext` - which allows you to pass down field specific context\\n\\nWhen the engine sees the `graphql.execution.DataFetcherResult` object, it automatically unpacks it and handles it three classes of data in specific ways.\\n\\nIn our example case we will be use `data` and `localContext` to communicate between fields easily.\\n\\n```java\\nDataFetcher issueDataFetcher = environment -> {\\n    DataFetchingFieldSelectionSet selectionSet = environment.getSelectionSet();\\n    if (selectionSet.contains(\\"comments\\")) {\\n        List<IssueAndCommentsDTO> data = getAllIssuesWithComments(environment, selectionSet.getFields());\\n\\n        List<IssueDTO> issues = data.stream().map(dto -> dto.getIssue()).collect(toList());\\n\\n        Map<IssueDTO, List<CommentDTO>> preFetchedComments = mkMapOfComments(data);\\n\\n        return DataFetcherResult.newResult()\\n                .data(issues)\\n                .localContext(preFetchedComments)\\n                .build();\\n    } else {\\n        List<IssueDTO> issues = getAllIssuesWitNoComments(environment);\\n        return DataFetcherResult.newResult()\\n                .data(issues)\\n                .build();\\n    }\\n};\\n```\\n\\nIf you look now you will see that our data fetcher returns a `DataFetcherResult` object that contains `data` for the child data fetchers which is the\\nlist of `issueDTO` objects as per usual.  It will be their `source` object when they run.\\n\\nIt also passes down field specific `localContext` which is the pre-fetched comment data.\\n\\nUnlike the global context object, local context objects are passed down from a specific field to its children and are not shared across to peer fields.  This means\\na parent field has a \\"back channel\\" to talk to the child fields without having to \\"pollute\\" the DTO source objects with that information and it is \\"local\\" in the sense\\nthat it given only to this field and its children and not any other field in the query.\\n\\nNow lets look at the `comments` data fetcher and how it consumes this back channel of data\\n\\n```java\\nDataFetcher commentsDataFetcher = environment -> {\\n    IssueDTO issueDTO = environment.getSource();\\n    Map<IssueDTO, List<CommentDTO>> preFetchedComments = environment.getLocalContext();\\n    List<CommentDTO> commentDTOS = preFetchedComments.get(issueDTO);\\n    return DataFetcherResult.newResult()\\n            .data(commentDTOS)\\n            .localContext(preFetchedComments)\\n            .build();\\n};\\n```\\n\\nNotice how it got the `issueDTO` as its source object as expected but it also got a local context object which is our pre-fetched comments.  It can choose\\nto pass on new local context OR if it passes nothing then the previous value will bubble down to the next lot of child fields.  So you can think of `localContext`\\nas being inherited unless a fields data fetcher explicitly overrides it.\\n\\nOur data fetcher is a bit more complex because of the data pre-fetching but \'localContext\' allows us a nice back channel to pass data without modifying our DTO objects\\nthat are being used in more simple data fetchers.\\n\\n# Passing back Errors or Data or Both\\n\\nFor completeness we will show you that you can also pass down errors or data or local context or all of them at once.\\n\\nIt is perfectly valid to fetch data in graphql and to ALSO send back errors.  Its not common but its valid. Some data is better than no data.\\n\\n```java\\nGraphQLError error = mkSpecialError(\\"Its Tuesday\\");\\n\\nreturn DataFetcherResult.newResult()\\n        .data(commentDTOS)\\n        .error(error)\\n        .build();\\n```"},{"id":"deep-dive-merged-fields","metadata":{"permalink":"/blog/deep-dive-merged-fields","editUrl":"https://github.com/graphql-java/graphql-java-page/edit/master/blog/blog/2019-01-22-deep-dive-merged-fields.md","source":"@site/blog/2019-01-22-deep-dive-merged-fields.md","title":"GraphQL Deep Dive Part 1 - merged fields","description":"Welcome to the new series \\"GraphQL deep dive\\" where we will explore advanced or unknown GraphQL topics. The plan is to discuss things mostly in a language and implementation neutral way, even if it is hosted on graphql-java.com.","date":"2019-01-22T00:00:00.000Z","formattedDate":"January 22, 2019","tags":[],"readingTime":3.995,"truncated":false,"authors":[{"name":"Andreas Marek","title":"Maintainer of GraphQL Java","url":"https://github.com/andimarek","imageURL":"https://github.com/andimarek.png","key":"andi"}],"prevItem":{"title":"Building efficient data fetchers by looking ahead","permalink":"/blog/deep-dive-data-fetcher-results"},"nextItem":{"title":"First release of GraphQL Java Spring","permalink":"/blog/graphql-java-spring-support"}},"content":"Welcome to the new series \\"GraphQL deep dive\\" where we will explore advanced or unknown GraphQL topics. The plan is to discuss things mostly in a language and implementation neutral way, even if it is hosted on graphql-java.com.\\n\\n# Merged Fields\\n\\nFirst thing we are looking at is \\"merged fields\\".\\n\\nGraphQL allows for a field to be declared multiple times in a query as long as it can be merged.\\n\\nValid GraphQL queries are:\\n\\n```graphql\\n{\\n  foo\\n  foo\\n}\\n```\\n\\n```graphql\\n{\\n  foo(id: \\"123\\")\\n  foo(id: \\"123\\")\\n  foo(id: \\"123\\")\\n}\\n```\\n\\n```graphql\\n{\\n  foo(id: \\"123\\") {\\n    id\\n  }\\n  foo(id: \\"123\\") {\\n    name\\n  }\\n  foo(id: \\"123\\") {\\n    id\\n    name\\n  }\\n}\\n```\\n\\nEach of these queries will result in a result with just one \\"foo\\" key, not two or three.\\n\\nInvalid Queries are:\\n\\n```graphql\\n{\\n  foo\\n  foo(id: \\"123\\")\\n}\\n```\\n\\n```graphql\\n{\\n  foo(id: \\"123\\")\\n  foo(id: \\"456\\", id2: \\"123\\")\\n}\\n```\\n\\n```graphql\\n{\\n  foo(id: \\"123\\")\\n  foo: foo2\\n}\\n```\\n\\nThe reason why they are not valid, is because the fields are different: in the first two examples the arguments differ and the third query actually has two different fields under the same key.\\n\\n# Motivation\\n\\nThe examples so far don\'t seem really useful, but it all makes sense when you add fragments:\\n\\n```graphql\\n{\\n  ...myFragment1\\n  ...myFragment2\\n}\\n\\nfragment myFragment1 on Query {\\n  foo(id: \\"123\\") {\\n    name\\n  }\\n}\\nfragment myFragment2 on Query {\\n  foo(id: \\"123\\") {\\n    url\\n  }\\n}\\n\\n```\\n\\nFragments are designed to be written by different parties (for example different components in a UI) which should not know anything about each other. Requiring that every field can only be declared once would make this objective unfeasible.\\n\\nBut by allowing fields merging, as long as the fields are the same, allows fragments to be authored in an independent way from each other.\\n\\n\\n# Rules when fields can be merged\\n\\nThe specific details when fields can be merged are written down in [Field Selection Merging](https://facebook.github.io/graphql/draft/#sec-Field-Selection-Merging) in the spec.\\n\\nThe rules are what you would expect in general and they basically say that fields must be the same. The following examples are taken from the spec and they are all valid:\\n\\n```graphql\\nfragment mergeIdenticalFields on Dog {\\n  name\\n  name\\n}\\nfragment mergeIdenticalAliasesAndFields on Dog {\\n  otherName: name\\n  otherName: name\\n}\\nfragment mergeIdenticalFieldsWithIdenticalArgs on Dog {\\n  doesKnowCommand(dogCommand: SIT)\\n  doesKnowCommand(dogCommand: SIT)\\n}\\nfragment mergeIdenticalFieldsWithIdenticalValues on Dog {\\n  doesKnowCommand(dogCommand: $dogCommand)\\n  doesKnowCommand(dogCommand: $dogCommand)\\n}\\n```\\n\\nThe most complex case happens when you have fields in fragments on different types:\\n\\n```graphql\\nfragment safeDifferingFields on Pet {\\n  ... on Dog {\\n    volume: barkVolume\\n  }\\n  ... on Cat {\\n    volume: meowVolume\\n  }\\n}\\n```\\n\\nThis is normally invalid because `volume` is an alias for two different fields `barkVolume` and `meowVolume` but because only one of the some are actually resolved and they both return a value of the same type (we assume here that `barkVolume` and `meowVolume` are both of the same type) it is valid.\\n\\n```graphql\\nfragment safeDifferingArgs on Pet {\\n  ... on Dog {\\n    doesKnowCommand(dogCommand: SIT)\\n  }\\n  ... on Cat {\\n    doesKnowCommand(catCommand: JUMP)\\n  }\\n}\\n```\\n\\nThis is again a valid case because even if the first `doesKnowCommand` has a different argument than the second `doesKnowCommand` only one of them is actually resolved.\\n\\nIn the next example `someValue` has different types (we assume that `nickname` is a `String` and `meowVolume` is a `Int`) and therefore the query is not valid:\\n\\n```graphql\\nfragment conflictingDifferingResponses on Pet {\\n  ... on Dog {\\n    someValue: nickname\\n  }\\n  ... on Cat {\\n    someValue: meowVolume\\n  }\\n}\\n```\\n\\n# Sub selections and directives\\n\\nOne thing to keep in my mind is that the sub selections of fields are merged together. For example here `foo` is resolved once and than `id` and `name` is resolved.\\n\\n```graphql\\n{\\n  foo(id: \\"123\\") {\\n    id\\n  }\\n  foo(id: \\"123\\") {\\n    name\\n  }\\n}\\n```\\n\\nThis query is the same as:\\n\\n```graphql\\n{\\n  foo(id: \\"123\\") {\\n    id\\n    name\\n  }\\n}\\n```\\n\\nThe second thing to keep in mind is that different directives can be on each field:\\n\\n```graphql\\n{\\n  foo(id: \\"123\\") @myDirective {\\n    id\\n  }\\n  foo(id: \\"123\\") @myOtherDirective {\\n    name\\n  }\\n}\\n```\\n\\nSo if you want to know all directives for the current field you are resolving you actually need to look at all of the merged fields from the query.\\n\\n# Merged fields in graphql-js and GraphQL Java\\n\\nIn graphql-js merged fields are relevant when you implement a resolver and you need access to the specific ast field of the query. The `info` objects has a property `fieldNodes` which gives you access to all ast fields which are merged together.\\n\\nIn GraphQL Java depending on the version you are running you have `List<Field> getFields()` in the `DataFetcherEnvironment` or for GraphQL Java newer than `12.0` you have also `MergedField getMergedField()` which is the recommend way to access all merged fields."},{"id":"graphql-java-spring-support","metadata":{"permalink":"/blog/graphql-java-spring-support","editUrl":"https://github.com/graphql-java/graphql-java-page/edit/master/blog/blog/2018-12-01-graphq-java-spring-support.md","source":"@site/blog/2018-12-01-graphq-java-spring-support.md","title":"First release of GraphQL Java Spring","description":"Spring for GraphQL is the official and current Spring integration. The integration is a collaboration between the Spring and GraphQL Java teams, and is maintained by the Spring team.","date":"2018-12-01T00:00:00.000Z","formattedDate":"December 1, 2018","tags":[],"readingTime":0.86,"truncated":false,"authors":[{"name":"Andreas Marek","title":"Maintainer of GraphQL Java","url":"https://github.com/andimarek","imageURL":"https://github.com/andimarek.png","key":"andi"}],"prevItem":{"title":"GraphQL Deep Dive Part 1 - merged fields","permalink":"/blog/deep-dive-merged-fields"},"nextItem":{"title":"Introducing graphql-java-extended-scalars","permalink":"/blog/introducing-extended-scalars"}},"content":":::caution\\n**[Spring for GraphQL](https://spring.io/projects/spring-graphql) is the official and current Spring integration.** The integration is a collaboration between the Spring and GraphQL Java teams, and is maintained by the Spring team. \\n\\n[We recommend using Spring for GraphQL](https://www.graphql-java.com/blog/spring-for-graphql), rather than the older Spring project mentioned in this blog post.\\n\\nSee our [Spring for GraphQL](https://www.graphql-java.com/tutorials/getting-started-with-spring-boot) tutorial for how to get started.\\n:::\\n\\nWe are happy to release the first version of the GraphQL Java Spring (Boot) project.\\n\\nAs [described before](https://www.graphql-java.com/blog/graphql-java-aims-to-be-used-directly/) this project\\ncomplements the GraphQL Java core project if you build a fully operational GraphQL server with Spring.\\n\\nCurrently it supports GET and POST requests and allows for some basic customization.\\n\\nIn future we are looking into supporting more advanced features like file upload or subscriptions.\\n\\nAs always contributions are more than welcome and we are hoping to grow this project together with the\\ncommunity: please open a [new issue](https://github.com/graphql-java/graphql-java-spring/issues/new) or leave a comment on [spectrum chat](https://spectrum.chat/graphql-java) about your wishes.\\n\\nMore details on how to use it can be found on the github page: https://github.com/graphql-java/graphql-java-spring"},{"id":"introducing-extended-scalars","metadata":{"permalink":"/blog/introducing-extended-scalars","editUrl":"https://github.com/graphql-java/graphql-java-page/edit/master/blog/blog/2018-11-24-introducing-extended-scalars.md","source":"@site/blog/2018-11-24-introducing-extended-scalars.md","title":"Introducing graphql-java-extended-scalars","description":"One of the most common questions we get in GraphQL Java land is \\"can we have a datetime scalar\\".","date":"2018-11-24T00:00:00.000Z","formattedDate":"November 24, 2018","tags":[],"readingTime":0.965,"truncated":false,"authors":[{"name":"Brad Baker","title":"Maintainer of GraphQL Java","url":"https://github.com/bbakerman","imageURL":"https://github.com/bbakerman.png","key":"brad"}],"prevItem":{"title":"First release of GraphQL Java Spring","permalink":"/blog/graphql-java-spring-support"},"nextItem":{"title":"GraphQL Java aims to be used directly","permalink":"/blog/graphql-java-aims-to-be-used-directly"}},"content":"One of the most common questions we get in GraphQL Java land is \\"can we have a datetime scalar\\".\\n\\nThis is not defined by the graphql specification per se so we are reluctant to add it to the core library and then have it turn\\nup later as an officially specified type.\\n\\nBut it really is a badly needed type in your GraphQL arsenal and hence `graphql-java-extended-scalars` was born\\n\\nhttps://github.com/graphql-java/graphql-java-extended-scalars\\n\\nThis will be a place where we can add non standard but useful extensions to GraphQL Java.\\n\\nThe major scalars we have added on day one are\\n\\n * The aforementioned DateTime scalar as well as a Date and Time scalar\\n * A Object scalar or sometimes know as a JSON scalar that allows a map of values to be returned as a scalar value\\n * Some numeric scalars that constrain the values allowed such as `PositiveInt`\\n * A Regex scalar that allows a string to fit a regular expression\\n * A Url scalar that produces `java.net.URL` objects at runtime\\n * And finally an aliasing technique that allows you to create more meaningfully named scalar values\\n\\n We hope you find them useful.\\n\\n\\nCheers,\\n\\nBrad"},{"id":"graphql-java-aims-to-be-used-directly","metadata":{"permalink":"/blog/graphql-java-aims-to-be-used-directly","editUrl":"https://github.com/graphql-java/graphql-java-page/edit/master/blog/blog/2018-11-10-graphql-java-aims-to-be-used-directly.md","source":"@site/blog/2018-11-10-graphql-java-aims-to-be-used-directly.md","title":"GraphQL Java aims to be used directly","description":"There seems to be a common misconception about GraphQL Java: that you should not use it directly,","date":"2018-11-10T00:00:00.000Z","formattedDate":"November 10, 2018","tags":[],"readingTime":1.825,"truncated":false,"authors":[{"name":"Andreas Marek","title":"Maintainer of GraphQL Java","url":"https://github.com/andimarek","imageURL":"https://github.com/andimarek.png","key":"andi"}],"prevItem":{"title":"Introducing graphql-java-extended-scalars","permalink":"/blog/introducing-extended-scalars"},"nextItem":{"title":"About breaking changes and Long-term support","permalink":"/blog/breaking-changes-and-lts"}},"content":"There seems to be a common misconception about GraphQL Java: that you should not use it directly,\\nbut rather use another library build on top of it.\\n\\nWe think it is important to make it clear, that this is not the case: GraphQL Java aims to be a library used directly\\nwithout any additionally abstraction on top. It was always build with this goal in mind.\\n\\nTo be fair: we didn\'t do a very good job so far to make that clear. For example up\\n[until recently](https://www.graphql-java.com/blog/moving-projects/) we hosted several other projects which\\nprovided abstractions on top of GraphQL Java. This was because of historical reasons and we didn\'t give any\\nguidance on when to use what. There are also currently more tutorials out there which don\'t use GraphQL Java directly\\ncompared to tutorials which do.\\n\\nThe other reason people might think that GraphQL Java is not suitable is because the [core project](https://github.com/graphql-java/graphql-java)\\ndoesn\'t provide any easy way to get a full service with HTTP endpoint up and running.\\nAnd the existing third party projects providing for example Spring Boot support\\nare adding abstractions.\\n\\nThe core project doesn\'t deal with any form of HTTP or JSON specific things and has on purpose basically no\\ndependencies at all. This will not change, but we recognize the need for having an easy way to get a\\nfull service up and running. This is why we are currently working on first class Spring (Boot) support.\\n\\n:::info\\nUpdate: You can now use [Spring for GraphQL](https://docs.spring.io/spring-graphql/reference/), the official GraphQL integration. It\'s a collaboration between the Spring and GraphQL Java teams. See our [quick start tutorial](https://www.graphql-java.com/tutorials/getting-started-with-spring-boot/).\\n:::\\n\\nThis is not done yet, but it will provide an easy way to integrate GraphQL Java in a Spring (Boot) application\\nwithout adding any abstraction on top of GraphQL Java. It will also be extended over time with more advanced features\\nlike Apollo Defer support.\\n\\n\\nTo recap:\\n\\n1. GraphQL Java aims to be a first class library used directly\\n1. The [GraphQL Java core project](https://github.com/graphql-java/graphql-java) doesn\'t deal with HTTP/JSON and will continue not do it\\n1. The [GraphQL Java Spring project](https://github.com/graphql-java/graphql-java-spring) will complement\\nthe core project in providing comprehensive Spring (Boot) support\\n\\nCheers,\\n\\nAndi"},{"id":"breaking-changes-and-lts","metadata":{"permalink":"/blog/breaking-changes-and-lts","editUrl":"https://github.com/graphql-java/graphql-java-page/edit/master/blog/blog/2018-10-20-breaking-changes-and-lts.md","source":"@site/blog/2018-10-20-breaking-changes-and-lts.md","title":"About breaking changes and Long-term support","description":"We are releasing new major versions of GraphQL Java roughly every 2 months. They are major versions because we break the API in it. We do it regularly and we prioritize clean code including good naming and design very high. Actually higher than API stability.","date":"2018-10-20T00:00:00.000Z","formattedDate":"October 20, 2018","tags":[],"readingTime":2.225,"truncated":false,"authors":[{"name":"Andreas Marek","title":"Maintainer of GraphQL Java","url":"https://github.com/andimarek","imageURL":"https://github.com/andimarek.png","key":"andi"}],"prevItem":{"title":"GraphQL Java aims to be used directly","permalink":"/blog/graphql-java-aims-to-be-used-directly"},"nextItem":{"title":"Moving to spectrum and new documentation home","permalink":"/blog/spectrum-and-new-doc"}},"content":"We are releasing new major versions of GraphQL Java roughly every 2 months. They are major versions because we break the API in it. We do it regularly and we prioritize clean code including good naming and design very high. Actually higher than API stability.\\n\\nWe do that because we are optimizing for long-term growth: GraphQL Java is 3 1/2 years old and it is just getting started. This means more people will be positively affected from a better experience compared to the ones who need to refactor.\\n\\nWe do it also because of resource constraints: we are an open source private run project with limited time and resources. We can\u2019t afford maintaining a badly designed project in the long-term. Every bad design, every bad naming makes adding features and adopting to new requirements harder, more time consuming and more unlikely. We also want to make external contributions as easy as possible because we can\u2019t do it all ourself.\\n\\nThe last reason is personal and it is about fun. I don\u2019t wanna maintain a badly designed project. I need to have fun if I wanna continue to invest a large amount of private time in GraphQL Java.\\n\\nDoes that mean we just refactor as crazy and break everything all the time? No it doesn\u2019t. We follow some rules about breaking changes:\\n\\n- We never take a functionality away. We deprecate things and make it clear that we don\u2019t really support them anymore, but we don\u2019t take them away without a clear alternative.\\n\\n- We try to favor simple breaking changes the compiler will catch. For example renaming a method is such a simple change.\\n\\n- We try to document in our release notes every breaking change clearly.\\n\\n- Even if we prioritize clean design higher than API stability in general we always weigh the benefits of the change vs the cost of adapting to it. There is no hard rule to that, but we always ask: is it worth it?\\n\\nBut  we understand that not every Organization allows for regular updating major versions of GraphQL Java. This is why we started to maintain a Long-term support (LTS) version of GraphQL Java: 9.x. We will continue to back port all bug fixes to 9.x for some time and we will announce when we will switch to a new LTS version.\\n\\nIt is not clear yet how long this time span will be and it depends also on your feedback. **Please contribute to this [spectrum thread](https://spectrum.chat/thread/196ab67d-2770-4f3f-b1b3-b056ecb3a2e1) and let us know what suits you best.** If you have special needs and you don\u2019t wanna discuss it in public you can also reach us via [contact form](https://www.graphql-java.com/contact/).\\n\\n\\nCheers,\\n\\nAndi"},{"id":"spectrum-and-new-doc","metadata":{"permalink":"/blog/spectrum-and-new-doc","editUrl":"https://github.com/graphql-java/graphql-java-page/edit/master/blog/blog/2018-10-10-spectrum-and-new-doc.md","source":"@site/blog/2018-10-10-spectrum-and-new-doc.md","title":"Moving to spectrum and new documentation home","description":"Update: we now use GitHub Discussions on the GitHub repository.","date":"2018-10-10T00:00:00.000Z","formattedDate":"October 10, 2018","tags":[],"readingTime":0.87,"truncated":false,"authors":[{"name":"Andreas Marek","title":"Maintainer of GraphQL Java","url":"https://github.com/andimarek","imageURL":"https://github.com/andimarek.png","key":"andi"}],"prevItem":{"title":"About breaking changes and Long-term support","permalink":"/blog/breaking-changes-and-lts"},"nextItem":{"title":"Moving projects out of the GraphQL Java org","permalink":"/blog/moving-projects"}},"content":":::info\\nUpdate: we now use GitHub Discussions on the [GitHub repository](https://github.com/graphql-java/graphql-java/discussions).\\n:::\\n\\nWe have two exciting changes to announce:\\n\\n# New support channel at spectrum\\n\\nWe are moving our support channel from [gitter](https://gitter.im/graphql-java/graphql-java) to [spectrum](https://spectrum.chat/graphql-java). Gitter served us well over the years, but with more and more people using GraphQL Java we are looking for better ways to support our community and we think spectrum is the right place to do that. Especially the Threads oriented view compared to one chat room is something we are looking forward to.\\n\\nPlease ask new questions at https://spectrum.chat/graphql-java. We will stop answering questions in the gitter room and direct people to spectrum. The gitter room will be closed in a couple of weeks.\\n\\n\\n# New documentation home\\n\\nWe are also moving our documentation from [readthedocs](https://graphql-java.readthedocs.io) to our own page at [graphql-java.com/documentation](https://www.graphql-java.com/documentation/).\\n\\nWhile the the new documentation is currently similar to the old one the layout is already an improvement and code examples are much easier readable than before. We are planning more improvements over time.\\n\\nCheers,\\n\\nAndi"},{"id":"moving-projects","metadata":{"permalink":"/blog/moving-projects","editUrl":"https://github.com/graphql-java/graphql-java-page/edit/master/blog/blog/2018-10-02-moving-projects.md","source":"@site/blog/2018-10-02-moving-projects.md","title":"Moving projects out of the GraphQL Java org","description":"Soon after I started started GraphQL Java (almost 3 1/2 years ago) other people started building libraries on top of it. I was happy to welcome them into the GraphQL Java Github organization, because it was great to see the GraphQL Java ecosystem grew and centralizing these projects into one org made sense.","date":"2018-10-02T00:00:00.000Z","formattedDate":"October 2, 2018","tags":[],"readingTime":1.035,"truncated":false,"authors":[{"name":"Andreas Marek","title":"Maintainer of GraphQL Java","url":"https://github.com/andimarek","imageURL":"https://github.com/andimarek.png","key":"andi"}],"prevItem":{"title":"Moving to spectrum and new documentation home","permalink":"/blog/spectrum-and-new-doc"},"nextItem":{"title":"Welcome to the new GraphQL Java homepage","permalink":"/blog/welcome-to-graphql-java"}},"content":"Soon after I started started GraphQL Java (almost 3 1/2 years ago) other people started building libraries on top of it. I was happy to welcome them into the [GraphQL Java Github organization](https://github.com/graphql-java/), because it was great to see the GraphQL Java ecosystem grew and centralizing these projects into one org made sense.\\n\\nFast forward to today: the core library [graphql-java](https://github.com/graphql-java/graphql-java) is maintained by myself and my co-maintainer Brad, but we are not involved in `graphql-spring-boot` and other projects. They are independently released and organized without any involvement from us. This leads to confusion from our users and makes it hard to recognize what actually the Graphql Java project is and what are libraries build on top without any involvement from Graphql Java.\\n\\nIn order to clear up this confusion we have decided to move these projects or to archive them:\\n\\n- `graphql-spring-boot` is moved to https://github.com/graphql-java-kickstart/graphql-spring-boot\\n- `graphql-java-tools` is moved to https://github.com/graphql-java-kickstart/graphql-java-tools\\n- `graphql-java-servlet` is moved to https://github.com/graphql-java-kickstart/graphql-java-servlet\\n- `graphql-java-annotations` is moved to https://github.com/Enigmatis/graphql-java-annotations\\n- `graphql-java-type-generator` is archived and  in read only mode: https://github.com/graphql-java/graphql-java-type-generator/\\n\\nI wanna make clear that these projects are valuable and successful projects and moving them out of the GraphQL Java Github organization is done to reduce confusion as described above.\\n\\nCheers,\\n\\nAndi"},{"id":"welcome-to-graphql-java","metadata":{"permalink":"/blog/welcome-to-graphql-java","editUrl":"https://github.com/graphql-java/graphql-java-page/edit/master/blog/blog/2018-10-01-welcome-to-graphql-java.md","source":"@site/blog/2018-10-01-welcome-to-graphql-java.md","title":"Welcome to the new GraphQL Java homepage","description":"Welcome to the new GraphQL Java Homepage: the central page about everything GraphQL Java.","date":"2018-10-01T00:00:00.000Z","formattedDate":"October 1, 2018","tags":[],"readingTime":0.16,"truncated":false,"authors":[{"name":"Andreas Marek","title":"Maintainer of GraphQL Java","url":"https://github.com/andimarek","imageURL":"https://github.com/andimarek.png","key":"andi"}],"prevItem":{"title":"Moving projects out of the GraphQL Java org","permalink":"/blog/moving-projects"}},"content":"Welcome to the new GraphQL Java Homepage: the central page about everything GraphQL Java.\\n\\nIt is still a work in progress and we will continue improving this page over time.\\n\\nCheers,\\n\\nAndi"}]}')}}]);