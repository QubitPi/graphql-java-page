"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4439],{5680:(e,t,n)=>{n.d(t,{xA:()=>d,yg:()=>u});var a=n(6540);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,s=e.originalType,l=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),p=c(n),u=o,m=p["".concat(l,".").concat(u)]||p[u]||h[u]||s;return n?a.createElement(m,i(i({ref:t},d),{},{components:n})):a.createElement(m,i({ref:t},d))}));function u(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var s=n.length,i=new Array(s);i[0]=p;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:o,i[1]=r;for(var c=2;c<s;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},4285:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>c,toc:()=>h});var a=n(8168),o=n(8587),s=(n(6540),n(5680)),i=["components"],r={title:"Building efficient data fetchers by looking ahead",authors:"brad",slug:"deep-dive-data-fetcher-results"},l="Efficient data fetchers",c={permalink:"/blog/deep-dive-data-fetcher-results",editUrl:"https://github.com/graphql-java/graphql-java-page/edit/master/blog/blog/2019-04-11-deep-dive-data-fetcher-results.md",source:"@site/blog/2019-04-11-deep-dive-data-fetcher-results.md",title:"Building efficient data fetchers by looking ahead",description:"Today we are looking into the graphql.schema.DataFetchingFieldSelectionSet and graphql.execution.DataFetcherResult objects as means",date:"2019-04-11T00:00:00.000Z",formattedDate:"April 11, 2019",tags:[],readingTime:4.865,truncated:!1,authors:[{name:"Brad Baker",title:"Maintainer of GraphQL Java",url:"https://github.com/bbakerman",imageURL:"https://github.com/bbakerman.png",key:"brad"}],prevItem:{title:"GraphQL Java and Threads",permalink:"/blog/threads"},nextItem:{title:"GraphQL Deep Dive Part 1 - merged fields",permalink:"/blog/deep-dive-merged-fields"}},d={authorsImageUrls:[void 0]},h=[],p={toc:h};function u(e){var t=e.components,n=(0,o.A)(e,i);return(0,s.yg)("wrapper",(0,a.A)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Today we are looking into the ",(0,s.yg)("inlineCode",{parentName:"p"},"graphql.schema.DataFetchingFieldSelectionSet")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"graphql.execution.DataFetcherResult")," objects as means\nto build efficient data fetchers."),(0,s.yg)("h1",{id:"the-scenario"},"The scenario"),(0,s.yg)("p",null,"But first lets set the scene. Imagine we have a system that can return ",(0,s.yg)("inlineCode",{parentName:"p"},"issues")," and the ",(0,s.yg)("inlineCode",{parentName:"p"},"comments")," on those ",(0,s.yg)("inlineCode",{parentName:"p"},"issues")),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-graphql"},"{\n  issues {\n    key\n    summary\n    comments {\n        text\n    }\n  }\n}\n")),(0,s.yg)("p",null,"Nominally we would have a ",(0,s.yg)("inlineCode",{parentName:"p"},"graphql.schema.DataFetcher")," on ",(0,s.yg)("inlineCode",{parentName:"p"},"issues")," that returns a list of issues and one on the field ",(0,s.yg)("inlineCode",{parentName:"p"},"comments")," that returns the list of comments\nfor each issue ",(0,s.yg)("inlineCode",{parentName:"p"},"source")," object."),(0,s.yg)("p",null,"As you can see this naively creates an ",(0,s.yg)("em",{parentName:"p"},"N+1 problem")," where we need to fetch data multiple times, one for each ",(0,s.yg)("inlineCode",{parentName:"p"},"issue")," object in isolation."),(0,s.yg)("p",null,"We could attack this using the ",(0,s.yg)("inlineCode",{parentName:"p"},"org.dataloader.DataLoader")," pattern but there is another way which will discuss in this article."),(0,s.yg)("h1",{id:"look-ahead-via-datafetchingfieldselectionset"},"Look ahead via DataFetchingFieldSelectionSet"),(0,s.yg)("p",null,"The data fetcher behind the ",(0,s.yg)("inlineCode",{parentName:"p"},"issues")," field is able to look ahead and see what sub fields are being asked for.  In this case it knows that ",(0,s.yg)("inlineCode",{parentName:"p"},"comments")," are being asked\nfor and hence it could prefetch them at the same time."),(0,s.yg)("p",null,(0,s.yg)("inlineCode",{parentName:"p"},"graphql.schema.DataFetchingEnvironment#getSelectionSet")," (aka ",(0,s.yg)("inlineCode",{parentName:"p"},"graphql.schema.DataFetchingFieldSelectionSet"),") can be used by data fetcher code to get the selection set of fields for a given parent field."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-java"},'DataFetcher issueDataFetcher = environment -> {\n    DataFetchingFieldSelectionSet selectionSet = environment.getSelectionSet();\n    if (selectionSet.contains("comments")) {\n        List<IssueAndCommentsDTO> data = getAllIssuesWithComments(environment, selectionSet.getFields());\n        return data;\n    } else {\n        List<IssueDTO> issues = getAllIssuesWitNoComments(environment);\n        return issues;\n    }\n};\n')),(0,s.yg)("p",null,"Imagine this is backed by an SQL system we might be able to use this field look ahead to produce the following SQL"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-sql"},"SELECT Issues.Key, Issues.Summary, Comments.Text\nFROM Issues\nINNER JOIN Comments ON Issues.CommentID=Comments.ID;\n")),(0,s.yg)("p",null,"So we have looked ahead and returned different data depending on the field sub selection.  We have made our system more efficient by using look ahead\nto fetch data just the ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," time and not ",(0,s.yg)("inlineCode",{parentName:"p"},"N+1")," times."),(0,s.yg)("h1",{id:"code-challenges"},"Code Challenges"),(0,s.yg)("p",null,"The challenge with this code design is that the shapes of the returned data is now field sub selection specific.  We needed a ",(0,s.yg)("inlineCode",{parentName:"p"},"IssueAndCommentsDTO")," for one sub selection\npath and a simpler ",(0,s.yg)("inlineCode",{parentName:"p"},"IssueDTO")," for another path."),(0,s.yg)("p",null,"With enough paths this becomes problematic as it adds new DTO classes per path and makes out child data fetchers more complex"),(0,s.yg)("p",null,"Also the standard graphql pattern is that the returned object becomes the ",(0,s.yg)("inlineCode",{parentName:"p"},"source")," ie. ",(0,s.yg)("inlineCode",{parentName:"p"},"graphql.schema.DataFetchingEnvironment#getSource")," of the next child\ndata fetcher.  But we might have pre fetched data that is needed 2 levels deep and this is challenging to do since each data fetcher would need to capture and copy\nthat data down to the layers below via new TDOs classes per level."),(0,s.yg)("h1",{id:"passing-data-and-local-context"},"Passing Data and Local Context"),(0,s.yg)("p",null,"GraphQL Java offers a capability that helps with this pattern.  GraphQL Java goes beyond what the reference graphql-js system gives you where the object you\nreturned is automatically the ",(0,s.yg)("inlineCode",{parentName:"p"},"source")," of the next child fetcher and that's all it can be."),(0,s.yg)("p",null,"In GraphQL Java you can use well known ",(0,s.yg)("inlineCode",{parentName:"p"},"graphql.execution.DataFetcherResult")," to return three sets of values"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"data"),"  - which will be used as the source on the next set of sub fields"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"errors")," - allowing you to return data as well as errors"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"localContext")," - which allows you to pass down field specific context")),(0,s.yg)("p",null,"When the engine sees the ",(0,s.yg)("inlineCode",{parentName:"p"},"graphql.execution.DataFetcherResult")," object, it automatically unpacks it and handles it three classes of data in specific ways."),(0,s.yg)("p",null,"In our example case we will be use ",(0,s.yg)("inlineCode",{parentName:"p"},"data")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"localContext")," to communicate between fields easily."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-java"},'DataFetcher issueDataFetcher = environment -> {\n    DataFetchingFieldSelectionSet selectionSet = environment.getSelectionSet();\n    if (selectionSet.contains("comments")) {\n        List<IssueAndCommentsDTO> data = getAllIssuesWithComments(environment, selectionSet.getFields());\n\n        List<IssueDTO> issues = data.stream().map(dto -> dto.getIssue()).collect(toList());\n\n        Map<IssueDTO, List<CommentDTO>> preFetchedComments = mkMapOfComments(data);\n\n        return DataFetcherResult.newResult()\n                .data(issues)\n                .localContext(preFetchedComments)\n                .build();\n    } else {\n        List<IssueDTO> issues = getAllIssuesWitNoComments(environment);\n        return DataFetcherResult.newResult()\n                .data(issues)\n                .build();\n    }\n};\n')),(0,s.yg)("p",null,"If you look now you will see that our data fetcher returns a ",(0,s.yg)("inlineCode",{parentName:"p"},"DataFetcherResult")," object that contains ",(0,s.yg)("inlineCode",{parentName:"p"},"data")," for the child data fetchers which is the\nlist of ",(0,s.yg)("inlineCode",{parentName:"p"},"issueDTO")," objects as per usual.  It will be their ",(0,s.yg)("inlineCode",{parentName:"p"},"source")," object when they run."),(0,s.yg)("p",null,"It also passes down field specific ",(0,s.yg)("inlineCode",{parentName:"p"},"localContext")," which is the pre-fetched comment data."),(0,s.yg)("p",null,'Unlike the global context object, local context objects are passed down from a specific field to its children and are not shared across to peer fields.  This means\na parent field has a "back channel" to talk to the child fields without having to "pollute" the DTO source objects with that information and it is "local" in the sense\nthat it given only to this field and its children and not any other field in the query.'),(0,s.yg)("p",null,"Now lets look at the ",(0,s.yg)("inlineCode",{parentName:"p"},"comments")," data fetcher and how it consumes this back channel of data"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-java"},"DataFetcher commentsDataFetcher = environment -> {\n    IssueDTO issueDTO = environment.getSource();\n    Map<IssueDTO, List<CommentDTO>> preFetchedComments = environment.getLocalContext();\n    List<CommentDTO> commentDTOS = preFetchedComments.get(issueDTO);\n    return DataFetcherResult.newResult()\n            .data(commentDTOS)\n            .localContext(preFetchedComments)\n            .build();\n};\n")),(0,s.yg)("p",null,"Notice how it got the ",(0,s.yg)("inlineCode",{parentName:"p"},"issueDTO")," as its source object as expected but it also got a local context object which is our pre-fetched comments.  It can choose\nto pass on new local context OR if it passes nothing then the previous value will bubble down to the next lot of child fields.  So you can think of ",(0,s.yg)("inlineCode",{parentName:"p"},"localContext"),"\nas being inherited unless a fields data fetcher explicitly overrides it."),(0,s.yg)("p",null,"Our data fetcher is a bit more complex because of the data pre-fetching but 'localContext' allows us a nice back channel to pass data without modifying our DTO objects\nthat are being used in more simple data fetchers."),(0,s.yg)("h1",{id:"passing-back-errors-or-data-or-both"},"Passing back Errors or Data or Both"),(0,s.yg)("p",null,"For completeness we will show you that you can also pass down errors or data or local context or all of them at once."),(0,s.yg)("p",null,"It is perfectly valid to fetch data in graphql and to ALSO send back errors.  Its not common but its valid. Some data is better than no data."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-java"},'GraphQLError error = mkSpecialError("Its Tuesday");\n\nreturn DataFetcherResult.newResult()\n        .data(commentDTOS)\n        .error(error)\n        .build();\n')))}u.isMDXComponent=!0}}]);