"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3905],{3905:function(t,e,n){n.d(e,{Zo:function(){return l},kt:function(){return f}});var a=n(7294);function o(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function r(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function i(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?r(Object(n),!0).forEach((function(e){o(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function p(t,e){if(null==t)return{};var n,a,o=function(t,e){if(null==t)return{};var n,a,o={},r=Object.keys(t);for(a=0;a<r.length;a++)n=r[a],e.indexOf(n)>=0||(o[n]=t[n]);return o}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(a=0;a<r.length;a++)n=r[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(o[n]=t[n])}return o}var c=a.createContext({}),s=function(t){var e=a.useContext(c),n=e;return t&&(n="function"==typeof t?t(e):i(i({},e),t)),n},l=function(t){var e=s(t.components);return a.createElement(c.Provider,{value:e},t.children)},u={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},d=a.forwardRef((function(t,e){var n=t.components,o=t.mdxType,r=t.originalType,c=t.parentName,l=p(t,["components","mdxType","originalType","parentName"]),d=s(n),f=o,h=d["".concat(c,".").concat(f)]||d[f]||u[f]||r;return n?a.createElement(h,i(i({ref:e},l),{},{components:n})):a.createElement(h,i({ref:e},l))}));function f(t,e){var n=arguments,o=e&&e.mdxType;if("string"==typeof t||o){var r=n.length,i=new Array(r);i[0]=d;var p={};for(var c in e)hasOwnProperty.call(e,c)&&(p[c]=e[c]);p.originalType=t,p.mdxType="string"==typeof t?t:o,i[1]=p;for(var s=2;s<r;s++)i[s]=n[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},4173:function(t,e,n){n.r(e),n.d(e,{frontMatter:function(){return p},contentTitle:function(){return c},metadata:function(){return s},toc:function(){return l},default:function(){return d}});var a=n(7462),o=n(3366),r=(n(7294),n(3905)),i=["components"],p={title:"Data mapping",date:new Date("2018-09-09T02:52:46.000Z"),description:"How graphql-java maps object data to graphql types"},c="Mapping data",s={unversionedId:"data-mapping",id:"version-v19/data-mapping",isDocsHomePage:!1,title:"Data mapping",description:"How graphql-java maps object data to graphql types",source:"@site/versioned_docs/version-v19/data-mapping.md",sourceDirName:".",slug:"/data-mapping",permalink:"/graphql-java-page/documentation/v19/data-mapping",editUrl:"https://github.com/graphql-java/graphql-java-page/edit/master/versioned_docs/version-v19/data-mapping.md",tags:[],version:"v19",frontMatter:{title:"Data mapping",date:"2018-09-09T02:52:46.000Z",description:"How graphql-java maps object data to graphql types"},sidebar:"version-v19/tutorialSidebar",previous:{title:"Data fetching",permalink:"/graphql-java-page/documentation/v19/data-fetching"},next:{title:"Exceptions",permalink:"/graphql-java-page/documentation/v19/exceptions"}},l=[{value:"How graphql maps object data to types",id:"how-graphql-maps-object-data-to-types",children:[],level:2}],u={toc:l};function d(t){var e=t.components,n=(0,o.Z)(t,i);return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"mapping-data"},"Mapping data"),(0,r.kt)("h2",{id:"how-graphql-maps-object-data-to-types"},"How graphql maps object data to types"),(0,r.kt)("p",null,"At its heart graphql is all about declaring a type schema and mapping that over backing runtime data."),(0,r.kt)("p",null,"As the designer of the type schema, it is your challenge to get these elements to meet in the middle."),(0,r.kt)("p",null,"For example imagine we want to have a graphql type schema as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"type Query {\n  products(match : String) : [Product]   # a list of products\n}\n\ntype Product {\n  id : ID\n  name : String\n  description : String\n  cost : Float\n  tax : Float\n}\n")),(0,r.kt)("p",null,"We could then run queries over this simple schema via a something like the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},'query ProductQuery {\n  products(match : "Paper*")\n  {\n    id, name, cost, tax\n  }\n}\n')),(0,r.kt)("p",null,"We will have a ",(0,r.kt)("inlineCode",{parentName:"p"},"DataFetcher")," on the ",(0,r.kt)("inlineCode",{parentName:"p"},"Query.products")," field that is responsible for finding a list of products that match\nthe argument passed in."),(0,r.kt)("p",null,"Now imagine we have 3 downstream services.  One that gets product information, one that gets product cost information and one that calculates\nproduct tax information."),(0,r.kt)("p",null,"graphql-java works by running data fetchers over objects for all that information and mapping that back to the types specified in the schema."),(0,r.kt)("p",null,"Our challenge is to take these 3 sources of information and present them as one unified type."),(0,r.kt)("p",null,"We could specify data fetchers on the ",(0,r.kt)("inlineCode",{parentName:"p"},"cost")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"tax")," fields that does those calculations but this is more to maintain and likely to lead to\n",(0,r.kt)("inlineCode",{parentName:"p"},"N+1 performance problems"),"."),(0,r.kt)("p",null,"We would be better to do all this work in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Query.products")," data fetcher and create a unified view of the data at that point."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'DataFetcher productsDataFetcher = new DataFetcher() {\n    @Override\n    public Object get(DataFetchingEnvironment env) {\n        String matchArg = env.getArgument("match");\n\n        List<ProductInfo> productInfo = getMatchingProducts(matchArg);\n\n        List<ProductCostInfo> productCostInfo = getProductCosts(productInfo);\n\n        List<ProductTaxInfo> productTaxInfo = getProductTax(productInfo);\n\n        return mapDataTogether(productInfo, productCostInfo, productTaxInfo);\n    }\n};\n')),(0,r.kt)("p",null,"So looking at the code above we have 3 types of information that need to be combined in a way such that a graphql query above can get access to\nthe fields ",(0,r.kt)("inlineCode",{parentName:"p"},"id, name, cost, tax")),(0,r.kt)("p",null,"We have two ways to create this mapping.  One is via using a not type safe ",(0,r.kt)("inlineCode",{parentName:"p"},"List<Map>")," structure and one by creating a type safe ",(0,r.kt)("inlineCode",{parentName:"p"},"List<ProductDTO>")," class that\nencapsulates this unified data."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Map")," technique could look like this."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'private List<Map> mapDataTogetherViaMap(List<ProductInfo> productInfo, List<ProductCostInfo> productCostInfo, List<ProductTaxInfo> productTaxInfo) {\n    List<Map> unifiedView = new ArrayList<>();\n    for (int i = 0; i < productInfo.size(); i++) {\n        ProductInfo info = productInfo.get(i);\n        ProductCostInfo cost = productCostInfo.get(i);\n        ProductTaxInfo tax = productTaxInfo.get(i);\n\n        Map<String, Object> objectMap = new HashMap<>();\n        objectMap.put("id", info.getId());\n        objectMap.put("name", info.getName());\n        objectMap.put("description", info.getDescription());\n        objectMap.put("cost", cost.getCost());\n        objectMap.put("tax", tax.getTax());\n\n        unifiedView.add(objectMap);\n    }\n    return unifiedView;\n}\n')),(0,r.kt)("p",null,"The more type safe ",(0,r.kt)("inlineCode",{parentName:"p"},"DTO")," technique could look like this."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"class ProductDTO {\n    private final String id;\n    private final String name;\n    private final String description;\n    private final Float cost;\n    private final Float tax;\n\n    public ProductDTO(String id, String name, String description, Float cost, Float tax) {\n        this.id = id;\n        this.name = name;\n        this.description = description;\n        this.cost = cost;\n        this.tax = tax;\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public Float getCost() {\n        return cost;\n    }\n\n    public Float getTax() {\n        return tax;\n    }\n}\n\nprivate List<ProductDTO> mapDataTogetherViaDTO(List<ProductInfo> productInfo, List<ProductCostInfo> productCostInfo, List<ProductTaxInfo> productTaxInfo) {\n    List<ProductDTO> unifiedView = new ArrayList<>();\n    for (int i = 0; i < productInfo.size(); i++) {\n        ProductInfo info = productInfo.get(i);\n        ProductCostInfo cost = productCostInfo.get(i);\n        ProductTaxInfo tax = productTaxInfo.get(i);\n\n        ProductDTO productDTO = new ProductDTO(\n                info.getId(),\n                info.getName(),\n                info.getDescription(),\n                cost.getCost(),\n                tax.getTax()\n        );\n        unifiedView.add(productDTO);\n    }\n    return unifiedView;\n}\n")),(0,r.kt)("p",null,"The graphql engine will now use that list of objects and run the query sub fields ",(0,r.kt)("inlineCode",{parentName:"p"},"id, name, cost, tax")," over it."),(0,r.kt)("p",null,"The default data fetcher in graphql-java is ",(0,r.kt)("inlineCode",{parentName:"p"},"graphql.schema.PropertyDataFetcher")," which has both map support and POJO support."),(0,r.kt)("p",null,"For every object in the list it will look for an ",(0,r.kt)("inlineCode",{parentName:"p"},"id")," field, find it by name in a map or via a ",(0,r.kt)("inlineCode",{parentName:"p"},"getId()")," getter method and that will be sent back in the graphql\nresponse.  It does that for every field in the query on that type."),(0,r.kt)("p",null,'By creating a "unified view" at the higher level data fetcher, you have mapped between your runtime view of the data and the graphql schema view of the data.'))}d.isMDXComponent=!0}}]);