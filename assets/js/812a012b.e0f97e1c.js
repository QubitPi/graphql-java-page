"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6860],{5680:(e,t,n)=>{n.d(t,{xA:()=>p,yg:()=>d});var a=n(6540);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var u=a.createContext({}),s=function(e){var t=a.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=s(e.components);return a.createElement(u.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,u=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),h=s(n),d=r,g=h["".concat(u,".").concat(d)]||h[d]||c[d]||i;return n?a.createElement(g,o(o({ref:t},p),{},{components:n})):a.createElement(g,o({ref:t},p))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=h;var l={};for(var u in t)hasOwnProperty.call(t,u)&&(l[u]=t[u]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var s=2;s<i;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},1088:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>u,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>p});var a=n(8168),r=n(8587),i=(n(6540),n(5680)),o=["components"],l={title:"Execution",date:new Date("2018-09-09T02:52:46.000Z"),description:"How to execute a query using the graphql-java engine"},u="Execution",s={unversionedId:"execution",id:"version-v24/execution",isDocsHomePage:!1,title:"Execution",description:"How to execute a query using the graphql-java engine",source:"@site/versioned_docs/version-v24/execution.md",sourceDirName:".",slug:"/execution",permalink:"/documentation/execution",editUrl:"https://github.com/graphql-java/graphql-java-page/edit/master/versioned_docs/version-v24/execution.md",tags:[],version:"v24",frontMatter:{title:"Execution",date:"2018-09-09T02:52:46.000Z",description:"How to execute a query using the graphql-java engine"},sidebar:"version-v24/tutorialSidebar",previous:{title:"Exceptions",permalink:"/documentation/exceptions"},next:{title:"Field selection",permalink:"/documentation/field-selection"}},p=[{value:"Queries",id:"queries",children:[],level:2},{value:"Data Fetchers",id:"data-fetchers",children:[],level:2},{value:"Exceptions while fetching data",id:"exceptions-while-fetching-data",children:[],level:2},{value:"Returning data and errors",id:"returning-data-and-errors",children:[],level:2},{value:"Serializing results to JSON",id:"serializing-results-to-json",children:[],level:2},{value:"Mutations",id:"mutations",children:[],level:2},{value:"Asynchronous Execution",id:"asynchronous-execution",children:[],level:2},{value:"Execution Strategies",id:"execution-strategies",children:[],level:2},{value:"AsyncExecutionStrategy",id:"asyncexecutionstrategy",children:[],level:2},{value:"AsyncSerialExecutionStrategy",id:"asyncserialexecutionstrategy",children:[],level:2},{value:"SubscriptionExecutionStrategy",id:"subscriptionexecutionstrategy",children:[],level:2},{value:"Query Caching",id:"query-caching",children:[],level:2}],c={toc:p};function h(e){var t=e.components,n=(0,r.A)(e,o);return(0,i.yg)("wrapper",(0,a.A)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"execution"},"Execution"),(0,i.yg)("h2",{id:"queries"},"Queries"),(0,i.yg)("p",null,"To execute a query against a schema, build a new ",(0,i.yg)("inlineCode",{parentName:"p"},"GraphQL")," object with the appropriate arguments and then\ncall ",(0,i.yg)("inlineCode",{parentName:"p"},"execute()"),"."),(0,i.yg)("p",null,"The result of a query is an ",(0,i.yg)("inlineCode",{parentName:"p"},"ExecutionResult")," which is the query data and/or a list of errors."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-java"},'GraphQLSchema schema = GraphQLSchema.newSchema()\n        .query(queryType)\n        .build();\n\nGraphQL graphQL = GraphQL.newGraphQL(schema)\n        .build();\n\nExecutionInput executionInput = ExecutionInput.newExecutionInput().query("query { hero { name } }")\n        .build();\n\nExecutionResult executionResult = graphQL.execute(executionInput);\n\nObject data = executionResult.getData();\nList<GraphQLError> errors = executionResult.getErrors();\n')),(0,i.yg)("p",null,"More complex query examples can be found in the ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/graphql-java/graphql-java/blob/master/src/test/groovy/graphql/StarWarsQueryTest.groovy"},"StarWars query tests")),(0,i.yg)("h2",{id:"data-fetchers"},"Data Fetchers"),(0,i.yg)("p",null,"Each graphql field type has a ",(0,i.yg)("inlineCode",{parentName:"p"},"graphql.schema.DataFetcher")," associated with it.  Other graphql implementations often call this\ntype of code ",(0,i.yg)("em",{parentName:"p"},"resolvers"),"."),(0,i.yg)("p",null,"Often you can rely on ",(0,i.yg)("inlineCode",{parentName:"p"},"graphql.schema.PropertyDataFetcher")," to examine Java POJO objects to\nprovide field values from them.  If you don't specify a data fetcher on a field, this is what will be used."),(0,i.yg)("p",null,"However you will need to fetch your top level domain objects via your own custom data fetchers.  This might involve making\na database call or contacting another system over HTTP say."),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"graphql-java")," is not opinionated about how you get your domain data objects, that is very much your concern.  It is also not\nopinionated on user authorisation to that data.  You should push all that logic into your business logic layer code."),(0,i.yg)("p",null,"A data fetcher might look like this:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-java"},'DataFetcher userDataFetcher = new DataFetcher() {\n    @Override\n    public Object get(DataFetchingEnvironment environment) {\n        return fetchUserFromDatabase(environment.getArgument("userId"));\n    }\n};\n')),(0,i.yg)("p",null,"Each ",(0,i.yg)("inlineCode",{parentName:"p"},"DataFetcher")," is passed a ",(0,i.yg)("inlineCode",{parentName:"p"},"graphql.schema.DataFetchingEnvironment")," object which contains what field is being fetched, what\narguments have been supplied to the field and other information such as the field's parent object, the query root object or the query\ncontext object."),(0,i.yg)("p",null,"In the example above, the execution will wait for the data fetcher to return before moving on.  You can make execution of\nthe ",(0,i.yg)("inlineCode",{parentName:"p"},"DataFetcher")," asynchronous by returning a ",(0,i.yg)("inlineCode",{parentName:"p"},"CompletionStage")," to data, that is explained more further down this page."),(0,i.yg)("h2",{id:"exceptions-while-fetching-data"},"Exceptions while fetching data"),(0,i.yg)("p",null,"If an exception happens during the data fetcher call, then the execution strategy by default will make a\n",(0,i.yg)("inlineCode",{parentName:"p"},"graphql.ExceptionWhileDataFetching")," error and add it to the list of errors on the result.  Remember graphql allows\npartial results with errors."),(0,i.yg)("p",null,"Here is the code for the standard behaviour."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-java"},"public class SimpleDataFetcherExceptionHandler implements DataFetcherExceptionHandler {\n\n    static final SimpleDataFetcherExceptionHandler defaultImpl = new SimpleDataFetcherExceptionHandler();\n\n    private DataFetcherExceptionHandlerResult handleExceptionImpl(DataFetcherExceptionHandlerParameters handlerParameters) {\n        Throwable exception = unwrap(handlerParameters.getException());\n        SourceLocation sourceLocation = handlerParameters.getSourceLocation();\n        ResultPath path = handlerParameters.getPath();\n\n        ExceptionWhileDataFetching error = new ExceptionWhileDataFetching(path, exception, sourceLocation);\n        logException(error, exception);\n\n        return DataFetcherExceptionHandlerResult.newResult().error(error).build();\n    }\n\n    @Override\n    public CompletableFuture<DataFetcherExceptionHandlerResult> handleException(DataFetcherExceptionHandlerParameters handlerParameters) {\n        return CompletableFuture.completedFuture(handleExceptionImpl(handlerParameters));\n    }\n\n    // See class for other methods\n}\n")),(0,i.yg)("p",null,"If the exception you throw is itself a ",(0,i.yg)("inlineCode",{parentName:"p"},"GraphqlError")," then it will transfer the message and custom extensions attributes from that exception\ninto the ",(0,i.yg)("inlineCode",{parentName:"p"},"ExceptionWhileDataFetching")," object.  This allows you to place your own custom attributes into the graphql error that is sent back\nto the caller."),(0,i.yg)("p",null,"For example imagine your data fetcher threw this exception.  The ",(0,i.yg)("inlineCode",{parentName:"p"},"foo")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"fizz")," attributes would be included in the resultant\ngraphql error."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-java"},'class CustomRuntimeException extends RuntimeException implements GraphQLError {\n    @Override\n    public Map<String, Object> getExtensions() {\n        Map<String, Object> customAttributes = new LinkedHashMap<>();\n        customAttributes.put("foo", "bar");\n        customAttributes.put("fizz", "whizz");\n        return customAttributes;\n    }\n\n    @Override\n    public List<SourceLocation> getLocations() {\n        return null;\n    }\n\n    @Override\n    public ErrorType getErrorType() {\n        return ErrorType.DataFetchingException;\n    }\n}\n')),(0,i.yg)("p",null,"You can change this behaviour by creating your own ",(0,i.yg)("inlineCode",{parentName:"p"},"graphql.execution.DataFetcherExceptionHandler")," exception handling code and\ngiving that to the execution strategy."),(0,i.yg)("p",null,"For example the code above records the underlying exception and stack trace.  Some people\nmay prefer not to see that in the output error list.  So you can use this mechanism to change that\nbehaviour."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-java"},"DataFetcherExceptionHandler handler = new DataFetcherExceptionHandler() {\n    @Override\n    public CompletableFuture<DataFetcherExceptionHandlerResult> handleException(DataFetcherExceptionHandlerParameters handlerParameters) {\n        // do your custom handling here.  The parameters have all you need\n    }\n};\nExecutionStrategy executionStrategy = new AsyncExecutionStrategy(handler);\n")),(0,i.yg)("h2",{id:"returning-data-and-errors"},"Returning data and errors"),(0,i.yg)("p",null,"It is also possible to return both data and multiple errors in a ",(0,i.yg)("inlineCode",{parentName:"p"},"DataFetcher")," implementation by returning\n",(0,i.yg)("inlineCode",{parentName:"p"},"graphql.execution.DataFetcherResult")," either directly or wrapped in a ",(0,i.yg)("inlineCode",{parentName:"p"},"CompletableFuture")," instance for asynchronous\nexecution.  This is a useful when your ",(0,i.yg)("inlineCode",{parentName:"p"},"DataFetcher")," may need to retrieve data from multiple sources or from another\nGraphQL resource."),(0,i.yg)("p",null,"In this example, the ",(0,i.yg)("inlineCode",{parentName:"p"},"DataFetcher")," retrieves a user from another GraphQL resource and returns its data and errors."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-java"},'DataFetcher userDataFetcher = new DataFetcher() {\n    @Override\n    public Object get(DataFetchingEnvironment environment) {\n        Map response = fetchUserFromRemoteGraphQLResource(environment.getArgument("userId"));\n        List<GraphQLError> errors = response.get("errors").stream()\n            .map(MyMapGraphQLError::new)\n            .collect(Collectors.toList());\n        return new DataFetcherResult(response.get("data"), errors);\n    }\n};\n')),(0,i.yg)("h2",{id:"serializing-results-to-json"},"Serializing results to JSON"),(0,i.yg)("p",null,"The most common way to call graphql is over HTTP and to expect a JSON response back.  So you need to turn an\n",(0,i.yg)("inlineCode",{parentName:"p"},"graphql.ExecutionResult")," into a JSON payload."),(0,i.yg)("p",null,"A common way to do that is use a JSON serialisation library like Jackson or GSON.  However exactly how they interpret the\ndata result is particular to them.  For example ",(0,i.yg)("inlineCode",{parentName:"p"},"nulls")," are important in graphql results and hence you must set up the json mappers\nto include them."),(0,i.yg)("p",null,"To ensure you get a JSON result that conforms 100% to the graphql spec, you should call ",(0,i.yg)("inlineCode",{parentName:"p"},"toSpecification")," on the result and then\nsend that back as JSON."),(0,i.yg)("p",null,"This will ensure that the result follows the specification outlined in ",(0,i.yg)("a",{parentName:"p",href:"http://facebook.github.io/graphql/#sec-Response"},"http://facebook.github.io/graphql/#sec-Response")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-java"},"ExecutionResult executionResult = graphQL.execute(executionInput);\n\nMap<String, Object> toSpecificationResult = executionResult.toSpecification();\n\nsendAsJson(toSpecificationResult);\n")),(0,i.yg)("h2",{id:"mutations"},"Mutations"),(0,i.yg)("p",null,"A good starting point to learn more about mutating data in graphql is ",(0,i.yg)("a",{parentName:"p",href:"http://graphql.org/learn/queries/#mutations"},"http://graphql.org/learn/queries/#mutations")),(0,i.yg)("p",null,"In essence you need to define a ",(0,i.yg)("inlineCode",{parentName:"p"},"GraphQLObjectType")," that takes arguments as input.  Those arguments are what you can use to mutate your data store\nvia the data fetcher invoked."),(0,i.yg)("p",null,"The mutation is invoked via a query like :"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-graphql"},"mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) {\n  createReview(episode: $ep, review: $review) {\n    stars\n    commentary\n  }\n}\n")),(0,i.yg)("p",null,"You need to send in arguments during that mutation operation, in this case for the variables for ",(0,i.yg)("inlineCode",{parentName:"p"},"$ep")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"$review")),(0,i.yg)("p",null,"You would create types like this to handle this mutation :"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-java"},'GraphQLInputObjectType episodeType = newInputObject()\n        .name("Episode")\n        .field(newInputObjectField()\n                .name("episodeNumber")\n                .type(Scalars.GraphQLInt))\n        .build();\n\nGraphQLInputObjectType reviewInputType = newInputObject()\n        .name("ReviewInput")\n        .field(newInputObjectField()\n                .name("stars")\n                .type(Scalars.GraphQLString)\n                .name("commentary")\n                .type(Scalars.GraphQLString))\n        .build();\n\nGraphQLObjectType reviewType = newObject()\n        .name("Review")\n        .field(newFieldDefinition()\n                .name("stars")\n                .type(GraphQLString))\n        .field(newFieldDefinition()\n                .name("commentary")\n                .type(GraphQLString))\n        .build();\n\nGraphQLObjectType createReviewForEpisodeMutation = newObject()\n        .name("CreateReviewForEpisodeMutation")\n        .field(newFieldDefinition()\n                .name("createReview")\n                .type(reviewType)\n                .argument(newArgument()\n                        .name("episode")\n                        .type(episodeType)\n                )\n                .argument(newArgument()\n                        .name("review")\n                        .type(reviewInputType)\n                )\n        )\n        .build();\n\nGraphQLCodeRegistry codeRegistry = newCodeRegistry()\n        .dataFetcher(\n                coordinates("CreateReviewForEpisodeMutation", "createReview"),\n                mutationDataFetcher()\n        )\n        .build();\n\n\nGraphQLSchema schema = GraphQLSchema.newSchema()\n        .query(queryType)\n        .mutation(createReviewForEpisodeMutation)\n        .codeRegistry(codeRegistry)\n        .build();\n')),(0,i.yg)("p",null,"Notice that the input arguments are of type ",(0,i.yg)("inlineCode",{parentName:"p"},"GraphQLInputObjectType"),".  This is important.  Input arguments can ONLY be of that type\nand you cannot use output types such as ",(0,i.yg)("inlineCode",{parentName:"p"},"GraphQLObjectType"),".  Scalars types are considered both input and output types."),(0,i.yg)("p",null,"The data fetcher here is responsible for executing the mutation and returning some sensible output values."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-java"},'private DataFetcher mutationDataFetcher() {\n    return new DataFetcher() {\n        @Override\n        public Review get(DataFetchingEnvironment environment) {\n            //\n            // The graphql specification dictates that input object arguments MUST\n            // be maps.  You can convert them to POJOs inside the data fetcher if that\n            // suits your code better\n            //\n            // See http://facebook.github.io/graphql/October2016/#sec-Input-Objects\n            //\n            Map<String, Object> episodeInputMap = environment.getArgument("episode");\n            Map<String, Object> reviewInputMap = environment.getArgument("review");\n\n            //\n            // in this case we have type safe Java objects to call our backing code with\n            //\n            EpisodeInput episodeInput = EpisodeInput.fromMap(episodeInputMap);\n            ReviewInput reviewInput = ReviewInput.fromMap(reviewInputMap);\n\n            // make a call to your store to mutate your database\n            Review updatedReview = reviewStore().update(episodeInput, reviewInput);\n\n            // this returns a new view of the data\n            return updatedReview;\n        }\n    };\n}\n')),(0,i.yg)("p",null,"Notice how it calls a data store to mutate the backing database and then returns a ",(0,i.yg)("inlineCode",{parentName:"p"},"Review")," object that can be used as the output values\nto the caller."),(0,i.yg)("h2",{id:"asynchronous-execution"},"Asynchronous Execution"),(0,i.yg)("p",null,"graphql-java uses fully asynchronous execution techniques when it executes queries.  You can get the ",(0,i.yg)("inlineCode",{parentName:"p"},"CompletableFuture")," to results by calling\n",(0,i.yg)("inlineCode",{parentName:"p"},"executeAsync()")," like this"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-java"},'GraphQL graphQL = buildSchema();\n\nExecutionInput executionInput = ExecutionInput.newExecutionInput().query("query { hero { name } }")\n        .build();\n\nCompletableFuture<ExecutionResult> promise = graphQL.executeAsync(executionInput);\n\npromise.thenAccept(executionResult -> {\n    // here you might send back the results as JSON over HTTP\n    encodeResultToJsonAndSendResponse(executionResult);\n});\n\npromise.join();\n')),(0,i.yg)("p",null,"The use of ",(0,i.yg)("inlineCode",{parentName:"p"},"CompletableFuture")," allows you to compose actions and functions that will be applied when the execution completes.  The final\ncall to ",(0,i.yg)("inlineCode",{parentName:"p"},".join()")," waits for the execution to happen."),(0,i.yg)("p",null,"In fact under the covers, the graphql-java engine uses asynchronous execution and makes the ",(0,i.yg)("inlineCode",{parentName:"p"},".execute()")," method appear synchronous by\ncalling join for you.  So the following code is in fact the same."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-java"},"ExecutionResult executionResult = graphQL.execute(executionInput);\n\n// the above is equivalent to the following code (in long hand)\n\nCompletableFuture<ExecutionResult> promise = graphQL.executeAsync(executionInput);\nExecutionResult executionResult2 = promise.join();\n")),(0,i.yg)("p",null,"If a ",(0,i.yg)("inlineCode",{parentName:"p"},"graphql.schema.DataFetcher")," returns a ",(0,i.yg)("inlineCode",{parentName:"p"},"CompletableFuture<T>")," object then this will be composed into the overall asynchronous\nquery execution.  This means you can fire off a number of field fetching requests in parallel.  Exactly what\nthreading strategy you use is up to your data fetcher code."),(0,i.yg)("p",null,"The following code uses the standard Java ",(0,i.yg)("inlineCode",{parentName:"p"},"java.util.concurrent.ForkJoinPool.commonPool()")," thread executor to supply values in another\nthread."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-java"},'DataFetcher userDataFetcher = new DataFetcher() {\n    @Override\n    public Object get(DataFetchingEnvironment environment) {\n        CompletableFuture<User> userPromise = CompletableFuture.supplyAsync(() -> {\n            return fetchUserViaHttp(environment.getArgument("userId"));\n        });\n        return userPromise;\n    }\n};\n')),(0,i.yg)("p",null,"The code above is written in long form.  With Java 8 lambdas it can be written more succinctly as follows"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-java"},'DataFetcher userDataFetcher = environment -> CompletableFuture.supplyAsync(\n        () -> fetchUserViaHttp(environment.getArgument("userId")));\n')),(0,i.yg)("p",null,"The graphql-java engine ensures that all the ",(0,i.yg)("inlineCode",{parentName:"p"},"CompletableFuture")," objects are composed together to provide an execution result\nthat follows the graphql specification."),(0,i.yg)("p",null,"There is a helpful shortcut in graphql-java to create asynchronous data fetchers.\nUse ",(0,i.yg)("inlineCode",{parentName:"p"},"graphql.schema.AsyncDataFetcher.async(DataFetcher<T>)")," to wrap a\n",(0,i.yg)("inlineCode",{parentName:"p"},"DataFetcher"),". This can be used with static imports to produce more readable code."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-java"},'DataFetcher userDataFetcher = async(environment -> fetchUserViaHttp(environment.getArgument("userId")));\n\n')),(0,i.yg)("h2",{id:"execution-strategies"},"Execution Strategies"),(0,i.yg)("p",null,"A class derived from ",(0,i.yg)("inlineCode",{parentName:"p"},"graphql.execution.ExecutionStrategy")," is used to run a query or mutation.  A number of different\nstrategies are provided with graphql-java and if you are really keen you can even write your own."),(0,i.yg)("p",null,"You can wire in what execution strategy to use when you create the ",(0,i.yg)("inlineCode",{parentName:"p"},"GraphQL")," object."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-java"},"GraphQL.newGraphQL(schema)\n        .queryExecutionStrategy(new AsyncExecutionStrategy())\n        .mutationExecutionStrategy(new AsyncSerialExecutionStrategy())\n        .build();\n")),(0,i.yg)("p",null,"In fact the code above is equivalent to the default settings and is a very sensible choice of execution\nstrategies for most cases."),(0,i.yg)("h2",{id:"asyncexecutionstrategy"},"AsyncExecutionStrategy"),(0,i.yg)("p",null,'By default the "query" execution strategy is ',(0,i.yg)("inlineCode",{parentName:"p"},"graphql.execution.AsyncExecutionStrategy")," which will dispatch\neach field as ",(0,i.yg)("inlineCode",{parentName:"p"},"CompletableFuture")," objects and not care which ones complete first.  This strategy allows for the most\nperformant execution."),(0,i.yg)("p",null,"The data fetchers invoked can themselves return ",(0,i.yg)("inlineCode",{parentName:"p"},"CompletionStage")," values and this will create\nfully asynchronous behaviour."),(0,i.yg)("p",null,"So imagine a query as follows"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-graphql"},"query {\n  hero {\n    enemies {\n      name\n    }\n    friends {\n      name\n    }\n  }\n}\n")),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"AsyncExecutionStrategy")," is free to dispatch the ",(0,i.yg)("em",{parentName:"p"},"enemies")," field at the same time as the ",(0,i.yg)("em",{parentName:"p"},"friends")," field.  It does not\nhave to do ",(0,i.yg)("em",{parentName:"p"},"enemies")," first followed by ",(0,i.yg)("em",{parentName:"p"},"friends"),", which would be less efficient."),(0,i.yg)("p",null,"It will however assemble the results in order.  The query result will follow the graphql specification and return object values\nassembled in query field order.  Only the execution of data fetching is free to be in any order."),(0,i.yg)("p",null,"This behaviour is allowed in the graphql specification and in fact is actively encouraged ",(0,i.yg)("a",{parentName:"p",href:"http://facebook.github.io/graphql/#sec-Query"},"http://facebook.github.io/graphql/#sec-Query"),"\nfor read only queries."),(0,i.yg)("p",null,"See ",(0,i.yg)("inlineCode",{parentName:"p"},"specification <http://facebook.github.io/graphql/#sec-Normal-evaluation>"),"_ for details."),(0,i.yg)("h2",{id:"asyncserialexecutionstrategy"},"AsyncSerialExecutionStrategy"),(0,i.yg)("p",null,"The graphql specification says that mutations MUST be executed serially and in the order in which the\nquery fields occur."),(0,i.yg)("p",null,"So ",(0,i.yg)("inlineCode",{parentName:"p"},"graphql.execution.AsyncSerialExecutionStrategy")," is used by default for mutations and will ensure that each\nfield is completed before it processes the next one and so forth.  You can still return ",(0,i.yg)("inlineCode",{parentName:"p"},"CompletionStage")," objects\nin the mutation data fetchers, however they will be executed serially and will be completed before the next\nmutation field data fetcher is dispatched."),(0,i.yg)("h2",{id:"subscriptionexecutionstrategy"},"SubscriptionExecutionStrategy"),(0,i.yg)("p",null,"Graphql subscriptions allows you to create stateful subscriptions to graphql data.  You uses ",(0,i.yg)("inlineCode",{parentName:"p"},"SubscriptionExecutionStrategy"),"\nas your execution strategy as it has the support for the reactive-streams APIs."),(0,i.yg)("p",null,"See ",(0,i.yg)("a",{parentName:"p",href:"http://www.reactive-streams.org/"},"http://www.reactive-streams.org/")," for more information on the reactive ",(0,i.yg)("inlineCode",{parentName:"p"},"Publisher")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"Subscriber")," interfaces."),(0,i.yg)("p",null,"Also see the page on ",(0,i.yg)("a",{parentName:"p",href:"/documentation/subscriptions"},"subscriptions")," for more details on how to write a subscription based graphql service."),(0,i.yg)("h2",{id:"query-caching"},"Query Caching"),(0,i.yg)("p",null,"Before the ",(0,i.yg)("inlineCode",{parentName:"p"},"graphql-java")," engine executes a query it must be parsed and validated, and this process can be somewhat time consuming."),(0,i.yg)("p",null,"To avoid the need for re-parse/validate the ",(0,i.yg)("inlineCode",{parentName:"p"},"GraphQL.Builder")," allows an instance of ",(0,i.yg)("inlineCode",{parentName:"p"},"PreparsedDocumentProvider")," to reuse ",(0,i.yg)("inlineCode",{parentName:"p"},"Document")," instances."),(0,i.yg)("p",null,"Please note that this does not cache the result of the query, only the parsed ",(0,i.yg)("inlineCode",{parentName:"p"},"Document"),"."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-java"},"Cache<String, PreparsedDocumentEntry> cache = Caffeine.newBuilder().maximumSize(10_000).build(); (1)\n\nPreparsedDocumentProvider preparsedCache = new PreparsedDocumentProvider() {\n    @Override\n    public CompletableFuture<PreparsedDocumentEntry> getDocumentAsync(ExecutionInput executionInput, Function<ExecutionInput, PreparsedDocumentEntry> computeFunction) {\n            Function<String, PreparsedDocumentEntry> mapCompute = key -> computeFunction.apply(executionInput);\n            return CompletableFuture.completedFuture(cache.get(executionInput.getQuery(), mapCompute));\n    }\n};\n\nGraphQL graphQL = GraphQL.newGraphQL(StarWarsSchema.starWarsSchema)\n        .preparsedDocumentProvider(preparsedCache) (2)\n        .build();\n")),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"Create an instance of preferred cache instance, here is ",(0,i.yg)("inlineCode",{parentName:"li"},"Caffeine <https://github.com/ben-manes/caffeine>"),"_  used as it is a high quality caching solution. The cache instance should be\nthread safe and shared."),(0,i.yg)("li",{parentName:"ol"},"The ",(0,i.yg)("inlineCode",{parentName:"li"},"PreparsedDocumentProvider")," is a functional interface with only a getDocument method This is called to get a ",(0,i.yg)("inlineCode",{parentName:"li"},"cached")," pre-parsed query and if its not present, then the computeFunction can be called to parse and validate the query.")),(0,i.yg)("p",null,"In order to achieve high cache hit ratio it is recommended that field arguments are passed in as variables instead of directly in the query."),(0,i.yg)("p",null,"The following query:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-graphql"},'query HelloTo {\n  sayHello(to: "Me") {\n    greeting\n  }\n}\n')),(0,i.yg)("p",null,"Should be rewritten as:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-graphql"},"query HelloTo($to: String!) {\n  sayHello(to: $to) {\n    greeting\n  }\n}\n")),(0,i.yg)("p",null,"with variables:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-json"},'{\n    "to": "Me"\n}\n')),(0,i.yg)("p",null,"The query is now reused regardless of variable values provided."))}h.isMDXComponent=!0}}]);