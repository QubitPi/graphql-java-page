"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3787],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return h}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),u=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(p.Provider,{value:t},e.children)},s={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,p=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=u(n),h=r,m=d["".concat(p,".").concat(h)]||d[h]||s[h]||o;return n?a.createElement(m,i(i({ref:t},c),{},{components:n})):a.createElement(m,i({ref:t},c))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var u=2;u<o;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},307:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return p},default:function(){return h},frontMatter:function(){return l},metadata:function(){return u},toc:function(){return s}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),i=["components"],l={title:"GraphQL Java and Threads",authors:"andi",slug:"threads"},p="GraphQL Java and Threads",u={permalink:"/graphql-java-page/blog/threads",editUrl:"https://github.com/graphql-java/graphql-java-page/edit/master/blog/blog/2021-02-05-threads.md",source:"@site/blog/2021-02-05-threads.md",title:"GraphQL Java and Threads",description:"We follow a fundamental rule in GraphQL Java regarding Threads: GraphQL Java never creates",date:"2021-02-05T00:00:00.000Z",formattedDate:"February 5, 2021",tags:[],readingTime:3.565,truncated:!1,authors:[{name:"Andreas Marek",title:"Maintainer of GraphQL Java",url:"https://github.com/andimarek",imageURL:"https://github.com/andimarek.png",key:"andi"}],prevItem:{title:"GraphQL spec releases are not important",permalink:"/graphql-java-page/blog/spec-releases-are-not-important"},nextItem:{title:"Building efficient data fetchers by looking ahead",permalink:"/graphql-java-page/blog/deep-dive-data-fetcher-results"}},c={authorsImageUrls:[void 0]},s=[],d={toc:s};function h(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"We follow a fundamental rule in GraphQL Java regarding Threads: GraphQL Java never creates\nThreads or interacts with Thread pools. We do this because we want to give the user the full control\nand whatever GraphQL Java would do, it would not be correct for every use case."),(0,o.kt)("p",null,"Additionally to being strictly unopinionated regarding Threads, GraphQL Java is also fully reactive,\nimplemented via ",(0,o.kt)("inlineCode",{parentName:"p"},"CompletableFuture")," (",(0,o.kt)("inlineCode",{parentName:"p"},"CF"),").\nThese two constrain together mean we rely on the ",(0,o.kt)("inlineCode",{parentName:"p"},"CF")," returned by the user.\nSpecifically we piggyback on the ",(0,o.kt)("inlineCode",{parentName:"p"},"CF")," returned by the ",(0,o.kt)("inlineCode",{parentName:"p"},"DataFetcher"),"\n(or other async methods which can be implemented by the user, but we focus here on ",(0,o.kt)("inlineCode",{parentName:"p"},"DataFetcher"),"\nas it is by far the most important)."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"// Pseudo code in GraphQL Java\n\nCompletableFuture<Object> dataFetcherResult = invokeDataFetcher();\ndataFetcherResult.thenApply(result -> {\n    // in which Thread  where this code happens is controlled by the CF returned\n    continueExecutingQuery(result);\n});\n")),(0,o.kt)("h1",{id:"blocking-datafetcher"},"Blocking DataFetcher"),(0,o.kt)("p",null,"Lets assume you are accessing a DB in a blocking way in your ",(0,o.kt)("inlineCode",{parentName:"p"},"DataFetcher"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"String get(DataFetchingEnvironment env) {\n    return getValueFromDb(env); // blocking the Thread until the value is read from DB\n};\n")),(0,o.kt)("p",null,"This is not completely wrong, but not recommend in general as the consequence of this kind of ",(0,o.kt)("inlineCode",{parentName:"p"},"DataFecher"),"\nis that GraphQL can't execute the query in the most efficient way."),(0,o.kt)("p",null,"For example for the following query:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-graphql"},"{\n  dbData1\n  dbData2\n  dbData3\n}\n")),(0,o.kt)("p",null,"If the ",(0,o.kt)("inlineCode",{parentName:"p"},"DataFetcher")," for these ",(0,o.kt)("inlineCode",{parentName:"p"},"dbData")," fields don't return a ",(0,o.kt)("inlineCode",{parentName:"p"},"CF"),",\nbut block the Thread until the data is read, GraphQL Java will not work with maximum efficiency."),(0,o.kt)("p",null,"GraphQL Java can invoke the ",(0,o.kt)("inlineCode",{parentName:"p"},"DataFetcher")," for all three fields in parallel. But if your ",(0,o.kt)("inlineCode",{parentName:"p"},"DataFetcher")," for\n",(0,o.kt)("inlineCode",{parentName:"p"},"dbData1")," is blocking, GraphQL Java will also be blocked and only invoke the next ",(0,o.kt)("inlineCode",{parentName:"p"},"DataFetcher")," once ",(0,o.kt)("inlineCode",{parentName:"p"},"dbData<n>"),"\nis finished.\nThe recommend solution to this problem is offloading your blocking code onto a separate Thread pool\nas shown here:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"CompletableFuture<String> get(DataFetchingEnvironment env) {\n    return CompletableFuture.supplyAsync( getValueFromDb(env), dbThreadPool );\n};\n")),(0,o.kt)("p",null,"This code will maximize the performance and will cause all three fields to be fetched in parallel."),(0,o.kt)("h1",{id:"different-pools-for-different-work"},"Different pools for different work"),(0,o.kt)("p",null,"The subsequent work done by GraphQL Java will be executed in the same ",(0,o.kt)("inlineCode",{parentName:"p"},"dbThreadPool")," until it\nencounters a new ",(0,o.kt)("inlineCode",{parentName:"p"},"DataFetcher")," returned by the user code and this new ",(0,o.kt)("inlineCode",{parentName:"p"},"CF")," dedicates the Thread\nfor the subsequent work."),(0,o.kt)("p",null,"If you want to have separate pools for different kind of work, one for the actual ",(0,o.kt)("inlineCode",{parentName:"p"},"DataFetcher")," which normally\ninvolve IO and one of the actual GraphQL Java work (which is pure CPU), you need to switch back from your offloaded\npool to a dedicated GraphQL Java pool before returning the ",(0,o.kt)("inlineCode",{parentName:"p"},"CF"),". You can achieve this with code like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"CompletableFuture<String> get(DataFetchingEnvironment env) {\n    return CompletableFuture.supplyAsync( getValueFromDb(env), dbThreadPool )\n        .handleAsync((result,exception) -> {\n            if(exception !=null) throw exception;\n            return result;\n        }, graphqlJavaPool);\n};\n")),(0,o.kt)("p",null,"Notice the ",(0,o.kt)("inlineCode",{parentName:"p"},".handleAsync")," which doesn't do anything except forwarding the result, but on a\ndifferent pool (",(0,o.kt)("inlineCode",{parentName:"p"},"graphqlJavaPool"),")."),(0,o.kt)("p",null,"This way you have different pools for different kind of work (one for CPU bound GraphQL Java work and one\nfor multiple ones for IO bound work), which can be configured and monitored independently."),(0,o.kt)("h1",{id:"in-a-fully-reactive-system"},"In a fully reactive system"),(0,o.kt)("p",null,"If your system is fully reactive your ",(0,o.kt)("inlineCode",{parentName:"p"},"DataFetcher")," will more look like this"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"CompletableFuture<String> get(DataFetchingEnvironment env) {\n    return callAnotherServiceNonBlocking(env); // returns CompletableFuture\n};\n")),(0,o.kt)("p",null,"The code above could be implemented via ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/AsyncHttpClient/async-http-client"},"Async Http Client"),"\nor ",(0,o.kt)("a",{parentName:"p",href:"https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-client"},"WebFlux WebClient"),".\nBoth provide fully reactive HTTP clients."),(0,o.kt)("p",null,"Because the code is non blocking there is no need to offload anything on a dedicated Thread pool to avoid blocking\nGraphQL Java."),(0,o.kt)("p",null,"You still might want to consider using a dedicated GraphQL Java pool as you otherwise would use\nThreads which are dedicated to IO. How much this is really relevant depends highly on your use case."),(0,o.kt)("p",null,"For example ",(0,o.kt)("inlineCode",{parentName:"p"},"Async Http Client")," (",(0,o.kt)("inlineCode",{parentName:"p"},"AHC"),") uses by default 2 * #cores (this value comes actually from Netty) Threads. If you\ndon't use a dedicated Thread Pool for GraphQL Java you might encounter situations under load where all ",(0,o.kt)("inlineCode",{parentName:"p"},"AHC"),"\nThreads are either busy or blocked by GraphQL Java code and as a result your system is not as performant as it\ncould be. Normally only load tests in production like environments can show the relevance of different Thread pools."),(0,o.kt)("h1",{id:"feedback-or-questions"},"Feedback or questions"),(0,o.kt)("p",null,"We use ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/graphql-java/graphql-java/discussions"},"GitHub Discussions")," for general feedback and questions."))}h.isMDXComponent=!0}}]);