"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6867],{5680:(e,n,a)=>{a.d(n,{xA:()=>g,yg:()=>u});var r=a(6540);function t(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function o(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,r)}return a}function l(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?o(Object(a),!0).forEach((function(n){t(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function i(e,n){if(null==e)return{};var a,r,t=function(e,n){if(null==e)return{};var a,r,t={},o=Object.keys(e);for(r=0;r<o.length;r++)a=o[r],n.indexOf(a)>=0||(t[a]=e[a]);return t}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)a=o[r],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(t[a]=e[a])}return t}var d=r.createContext({}),s=function(e){var n=r.useContext(d),a=n;return e&&(a="function"==typeof e?e(n):l(l({},n),e)),a},g=function(e){var n=s(e.components);return r.createElement(d.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var a=e.components,t=e.mdxType,o=e.originalType,d=e.parentName,g=i(e,["components","mdxType","originalType","parentName"]),m=s(a),u=t,c=m["".concat(d,".").concat(u)]||m[u]||p[u]||o;return a?r.createElement(c,l(l({ref:n},g),{},{components:a})):r.createElement(c,l({ref:n},g))}));function u(e,n){var a=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var o=a.length,l=new Array(o);l[0]=m;var i={};for(var d in n)hasOwnProperty.call(n,d)&&(i[d]=n[d]);i.originalType=e,i.mdxType="string"==typeof e?e:t,l[1]=i;for(var s=2;s<o;s++)l[s]=a[s];return r.createElement.apply(null,l)}return r.createElement.apply(null,a)}m.displayName="MDXCreateElement"},9291:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>g,contentTitle:()=>d,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var r=a(8168),t=a(8587),o=(a(6540),a(5680)),l=["components"],i={title:"GraphQL Deep Dive Part 1 - merged fields",authors:"andi",slug:"deep-dive-merged-fields"},d="GraphQL Deep Dive series",s={permalink:"/blog/deep-dive-merged-fields",editUrl:"https://github.com/graphql-java/graphql-java-page/edit/master/blog/blog/2019-01-22-deep-dive-merged-fields.md",source:"@site/blog/2019-01-22-deep-dive-merged-fields.md",title:"GraphQL Deep Dive Part 1 - merged fields",description:'Welcome to the new series "GraphQL deep dive" where we will explore advanced or unknown GraphQL topics. The plan is to discuss things mostly in a language and implementation neutral way, even if it is hosted on graphql-java.com.',date:"2019-01-22T00:00:00.000Z",formattedDate:"January 22, 2019",tags:[],readingTime:3.995,truncated:!1,authors:[{name:"Andreas Marek",title:"Maintainer of GraphQL Java",url:"https://github.com/andimarek",imageURL:"https://github.com/andimarek.png",key:"andi"}],prevItem:{title:"Building efficient data fetchers by looking ahead",permalink:"/blog/deep-dive-data-fetcher-results"},nextItem:{title:"First release of GraphQL Java Spring",permalink:"/blog/graphql-java-spring-support"}},g={authorsImageUrls:[void 0]},p=[],m={toc:p};function u(e){var n=e.components,a=(0,t.A)(e,l);return(0,o.yg)("wrapper",(0,r.A)({},m,a,{components:n,mdxType:"MDXLayout"}),(0,o.yg)("p",null,'Welcome to the new series "GraphQL deep dive" where we will explore advanced or unknown GraphQL topics. The plan is to discuss things mostly in a language and implementation neutral way, even if it is hosted on graphql-java.com.'),(0,o.yg)("h1",{id:"merged-fields"},"Merged Fields"),(0,o.yg)("p",null,'First thing we are looking at is "merged fields".'),(0,o.yg)("p",null,"GraphQL allows for a field to be declared multiple times in a query as long as it can be merged."),(0,o.yg)("p",null,"Valid GraphQL queries are:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-graphql"},"{\n  foo\n  foo\n}\n")),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-graphql"},'{\n  foo(id: "123")\n  foo(id: "123")\n  foo(id: "123")\n}\n')),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-graphql"},'{\n  foo(id: "123") {\n    id\n  }\n  foo(id: "123") {\n    name\n  }\n  foo(id: "123") {\n    id\n    name\n  }\n}\n')),(0,o.yg)("p",null,'Each of these queries will result in a result with just one "foo" key, not two or three.'),(0,o.yg)("p",null,"Invalid Queries are:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-graphql"},'{\n  foo\n  foo(id: "123")\n}\n')),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-graphql"},'{\n  foo(id: "123")\n  foo(id: "456", id2: "123")\n}\n')),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-graphql"},'{\n  foo(id: "123")\n  foo: foo2\n}\n')),(0,o.yg)("p",null,"The reason why they are not valid, is because the fields are different: in the first two examples the arguments differ and the third query actually has two different fields under the same key."),(0,o.yg)("h1",{id:"motivation"},"Motivation"),(0,o.yg)("p",null,"The examples so far don't seem really useful, but it all makes sense when you add fragments:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-graphql"},'{\n  ...myFragment1\n  ...myFragment2\n}\n\nfragment myFragment1 on Query {\n  foo(id: "123") {\n    name\n  }\n}\nfragment myFragment2 on Query {\n  foo(id: "123") {\n    url\n  }\n}\n\n')),(0,o.yg)("p",null,"Fragments are designed to be written by different parties (for example different components in a UI) which should not know anything about each other. Requiring that every field can only be declared once would make this objective unfeasible."),(0,o.yg)("p",null,"But by allowing fields merging, as long as the fields are the same, allows fragments to be authored in an independent way from each other."),(0,o.yg)("h1",{id:"rules-when-fields-can-be-merged"},"Rules when fields can be merged"),(0,o.yg)("p",null,"The specific details when fields can be merged are written down in ",(0,o.yg)("a",{parentName:"p",href:"https://facebook.github.io/graphql/draft/#sec-Field-Selection-Merging"},"Field Selection Merging")," in the spec."),(0,o.yg)("p",null,"The rules are what you would expect in general and they basically say that fields must be the same. The following examples are taken from the spec and they are all valid:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-graphql"},"fragment mergeIdenticalFields on Dog {\n  name\n  name\n}\nfragment mergeIdenticalAliasesAndFields on Dog {\n  otherName: name\n  otherName: name\n}\nfragment mergeIdenticalFieldsWithIdenticalArgs on Dog {\n  doesKnowCommand(dogCommand: SIT)\n  doesKnowCommand(dogCommand: SIT)\n}\nfragment mergeIdenticalFieldsWithIdenticalValues on Dog {\n  doesKnowCommand(dogCommand: $dogCommand)\n  doesKnowCommand(dogCommand: $dogCommand)\n}\n")),(0,o.yg)("p",null,"The most complex case happens when you have fields in fragments on different types:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-graphql"},"fragment safeDifferingFields on Pet {\n  ... on Dog {\n    volume: barkVolume\n  }\n  ... on Cat {\n    volume: meowVolume\n  }\n}\n")),(0,o.yg)("p",null,"This is normally invalid because ",(0,o.yg)("inlineCode",{parentName:"p"},"volume")," is an alias for two different fields ",(0,o.yg)("inlineCode",{parentName:"p"},"barkVolume")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"meowVolume")," but because only one of the some are actually resolved and they both return a value of the same type (we assume here that ",(0,o.yg)("inlineCode",{parentName:"p"},"barkVolume")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"meowVolume")," are both of the same type) it is valid."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-graphql"},"fragment safeDifferingArgs on Pet {\n  ... on Dog {\n    doesKnowCommand(dogCommand: SIT)\n  }\n  ... on Cat {\n    doesKnowCommand(catCommand: JUMP)\n  }\n}\n")),(0,o.yg)("p",null,"This is again a valid case because even if the first ",(0,o.yg)("inlineCode",{parentName:"p"},"doesKnowCommand")," has a different argument than the second ",(0,o.yg)("inlineCode",{parentName:"p"},"doesKnowCommand")," only one of them is actually resolved."),(0,o.yg)("p",null,"In the next example ",(0,o.yg)("inlineCode",{parentName:"p"},"someValue")," has different types (we assume that ",(0,o.yg)("inlineCode",{parentName:"p"},"nickname")," is a ",(0,o.yg)("inlineCode",{parentName:"p"},"String")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"meowVolume")," is a ",(0,o.yg)("inlineCode",{parentName:"p"},"Int"),") and therefore the query is not valid:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-graphql"},"fragment conflictingDifferingResponses on Pet {\n  ... on Dog {\n    someValue: nickname\n  }\n  ... on Cat {\n    someValue: meowVolume\n  }\n}\n")),(0,o.yg)("h1",{id:"sub-selections-and-directives"},"Sub selections and directives"),(0,o.yg)("p",null,"One thing to keep in my mind is that the sub selections of fields are merged together. For example here ",(0,o.yg)("inlineCode",{parentName:"p"},"foo")," is resolved once and than ",(0,o.yg)("inlineCode",{parentName:"p"},"id")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"name")," is resolved."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-graphql"},'{\n  foo(id: "123") {\n    id\n  }\n  foo(id: "123") {\n    name\n  }\n}\n')),(0,o.yg)("p",null,"This query is the same as:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-graphql"},'{\n  foo(id: "123") {\n    id\n    name\n  }\n}\n')),(0,o.yg)("p",null,"The second thing to keep in mind is that different directives can be on each field:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-graphql"},'{\n  foo(id: "123") @myDirective {\n    id\n  }\n  foo(id: "123") @myOtherDirective {\n    name\n  }\n}\n')),(0,o.yg)("p",null,"So if you want to know all directives for the current field you are resolving you actually need to look at all of the merged fields from the query."),(0,o.yg)("h1",{id:"merged-fields-in-graphql-js-and-graphql-java"},"Merged fields in graphql-js and GraphQL Java"),(0,o.yg)("p",null,"In graphql-js merged fields are relevant when you implement a resolver and you need access to the specific ast field of the query. The ",(0,o.yg)("inlineCode",{parentName:"p"},"info")," objects has a property ",(0,o.yg)("inlineCode",{parentName:"p"},"fieldNodes")," which gives you access to all ast fields which are merged together."),(0,o.yg)("p",null,"In GraphQL Java depending on the version you are running you have ",(0,o.yg)("inlineCode",{parentName:"p"},"List<Field> getFields()")," in the ",(0,o.yg)("inlineCode",{parentName:"p"},"DataFetcherEnvironment")," or for GraphQL Java newer than ",(0,o.yg)("inlineCode",{parentName:"p"},"12.0")," you have also ",(0,o.yg)("inlineCode",{parentName:"p"},"MergedField getMergedField()")," which is the recommend way to access all merged fields."))}u.isMDXComponent=!0}}]);