"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9568],{3905:function(e,t,n){n.d(t,{Zo:function(){return s},kt:function(){return m}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},s=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,s=p(e,["components","mdxType","originalType","parentName"]),d=u(n),m=i,h=d["".concat(l,".").concat(m)]||d[m]||c[m]||o;return n?a.createElement(h,r(r({ref:t},s),{},{components:n})):a.createElement(h,r({ref:t},s))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=d;var p={};for(var l in t)hasOwnProperty.call(t,l)&&(p[l]=t[l]);p.originalType=e,p.mdxType="string"==typeof e?e:i,r[1]=p;for(var u=2;u<o;u++)r[u]=n[u];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},8016:function(e,t,n){n.r(t),n.d(t,{contentTitle:function(){return l},default:function(){return d},frontMatter:function(){return p},metadata:function(){return u},toc:function(){return s}});var a=n(7462),i=n(3366),o=(n(7294),n(3905)),r=["components"],p={title:"Data mapping",date:new Date("2018-09-09T02:52:46.000Z"),description:"How graphql-java maps object data to graphql types"},l="Mapping output data",u={unversionedId:"data-mapping",id:"version-v21/data-mapping",isDocsHomePage:!1,title:"Data mapping",description:"How graphql-java maps object data to graphql types",source:"@site/versioned_docs/version-v21/data-mapping.md",sourceDirName:".",slug:"/data-mapping",permalink:"/documentation/v21/data-mapping",editUrl:"https://github.com/graphql-java/graphql-java-page/edit/master/versioned_docs/version-v21/data-mapping.md",tags:[],version:"v21",frontMatter:{title:"Data mapping",date:"2018-09-09T02:52:46.000Z",description:"How graphql-java maps object data to graphql types"},sidebar:"version-v21/tutorialSidebar",previous:{title:"Data fetching",permalink:"/documentation/v21/data-fetching"},next:{title:"Exceptions",permalink:"/documentation/v21/exceptions"}},s=[{value:"How graphql maps object data to output types",id:"how-graphql-maps-object-data-to-output-types",children:[],level:2},{value:"How graphql maps object data to input types",id:"how-graphql-maps-object-data-to-input-types",children:[{value:"Enums",id:"enums",children:[],level:3},{value:"Scalars",id:"scalars",children:[],level:3},{value:"Input Object Types",id:"input-object-types",children:[],level:3},{value:"Nonnull input types",id:"nonnull-input-types",children:[],level:3},{value:"Lists of input types",id:"lists-of-input-types",children:[],level:3}],level:2}],c={toc:s};function d(e){var t=e.components,n=(0,i.Z)(e,r);return(0,o.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"mapping-output-data"},"Mapping output data"),(0,o.kt)("h2",{id:"how-graphql-maps-object-data-to-output-types"},"How graphql maps object data to output types"),(0,o.kt)("p",null,"At its heart graphql is all about declaring a type schema and mapping that over backing runtime data."),(0,o.kt)("p",null,"As the designer of the type schema, it is your challenge to get these elements to meet in the middle."),(0,o.kt)("p",null,"For example imagine we want to have a graphql type schema as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-graphql"},"type Query {\n  products(match : String) : [Product]   # a list of products\n}\n\ntype Product {\n  id : ID\n  name : String\n  description : String\n  cost : Float\n  tax : Float\n}\n")),(0,o.kt)("p",null,"We could then run queries over this simple schema via a something like the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-graphql"},'query ProductQuery {\n  products(match : "Paper*")\n  {\n    id, name, cost, tax\n  }\n}\n')),(0,o.kt)("p",null,"We will have a ",(0,o.kt)("inlineCode",{parentName:"p"},"DataFetcher")," on the ",(0,o.kt)("inlineCode",{parentName:"p"},"Query.products")," field that is responsible for finding a list of products that match\nthe argument passed in."),(0,o.kt)("p",null,"Now imagine we have 3 downstream services.  One that gets product information, one that gets product cost information and one that calculates\nproduct tax information."),(0,o.kt)("p",null,"graphql-java works by running data fetchers over objects for all that information and mapping that back to the types specified in the schema."),(0,o.kt)("p",null,"Our challenge is to take these 3 sources of information and present them as one unified type."),(0,o.kt)("p",null,"We could specify data fetchers on the ",(0,o.kt)("inlineCode",{parentName:"p"},"cost")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"tax")," fields that does those calculations but this is more to maintain and likely to lead to\n",(0,o.kt)("a",{parentName:"p",href:"https://stackoverflow.com/a/97253/14312712"},"N+1 performance problems"),"."),(0,o.kt)("p",null,"We would be better to do all this work in the ",(0,o.kt)("inlineCode",{parentName:"p"},"Query.products")," data fetcher and create a unified view of the data at that point."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'DataFetcher productsDataFetcher = new DataFetcher() {\n    @Override\n    public Object get(DataFetchingEnvironment env) {\n        String matchArg = env.getArgument("match");\n\n        List<ProductInfo> productInfo = getMatchingProducts(matchArg);\n\n        List<ProductCostInfo> productCostInfo = getProductCosts(productInfo);\n\n        List<ProductTaxInfo> productTaxInfo = getProductTax(productInfo);\n\n        return mapDataTogether(productInfo, productCostInfo, productTaxInfo);\n    }\n};\n')),(0,o.kt)("p",null,"So looking at the code above we have 3 types of information that need to be combined in a way such that a graphql query above can get access to\nthe fields ",(0,o.kt)("inlineCode",{parentName:"p"},"id, name, cost, tax")),(0,o.kt)("p",null,"We have two ways to create this mapping.  One is via using a not type safe ",(0,o.kt)("inlineCode",{parentName:"p"},"List<Map>")," structure and one by creating a type safe ",(0,o.kt)("inlineCode",{parentName:"p"},"List<ProductDTO>")," class that\nencapsulates this unified data."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Map")," technique could look like this."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'private List<Map> mapDataTogetherViaMap(List<ProductInfo> productInfo, List<ProductCostInfo> productCostInfo, List<ProductTaxInfo> productTaxInfo) {\n    List<Map> unifiedView = new ArrayList<>();\n    for (int i = 0; i < productInfo.size(); i++) {\n        ProductInfo info = productInfo.get(i);\n        ProductCostInfo cost = productCostInfo.get(i);\n        ProductTaxInfo tax = productTaxInfo.get(i);\n\n        Map<String, Object> objectMap = new HashMap<>();\n        objectMap.put("id", info.getId());\n        objectMap.put("name", info.getName());\n        objectMap.put("description", info.getDescription());\n        objectMap.put("cost", cost.getCost());\n        objectMap.put("tax", tax.getTax());\n\n        unifiedView.add(objectMap);\n    }\n    return unifiedView;\n}\n')),(0,o.kt)("p",null,"The more type safe ",(0,o.kt)("inlineCode",{parentName:"p"},"DTO")," technique could look like this."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"class ProductDTO {\n    private final String id;\n    private final String name;\n    private final String description;\n    private final Float cost;\n    private final Float tax;\n\n    public ProductDTO(String id, String name, String description, Float cost, Float tax) {\n        this.id = id;\n        this.name = name;\n        this.description = description;\n        this.cost = cost;\n        this.tax = tax;\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public Float getCost() {\n        return cost;\n    }\n\n    public Float getTax() {\n        return tax;\n    }\n}\n\nprivate List<ProductDTO> mapDataTogetherViaDTO(List<ProductInfo> productInfo, List<ProductCostInfo> productCostInfo, List<ProductTaxInfo> productTaxInfo) {\n    List<ProductDTO> unifiedView = new ArrayList<>();\n    for (int i = 0; i < productInfo.size(); i++) {\n        ProductInfo info = productInfo.get(i);\n        ProductCostInfo cost = productCostInfo.get(i);\n        ProductTaxInfo tax = productTaxInfo.get(i);\n\n        ProductDTO productDTO = new ProductDTO(\n                info.getId(),\n                info.getName(),\n                info.getDescription(),\n                cost.getCost(),\n                tax.getTax()\n        );\n        unifiedView.add(productDTO);\n    }\n    return unifiedView;\n}\n")),(0,o.kt)("p",null,"The graphql engine will now use that list of objects and run the query sub fields ",(0,o.kt)("inlineCode",{parentName:"p"},"id, name, cost, tax")," over it."),(0,o.kt)("p",null,"The default data fetcher in graphql-java is ",(0,o.kt)("inlineCode",{parentName:"p"},"graphql.schema.PropertyDataFetcher")," which has both map support and POJO support."),(0,o.kt)("p",null,"For every object in the list it will look for an ",(0,o.kt)("inlineCode",{parentName:"p"},"id")," field, find it by name in a map or via a ",(0,o.kt)("inlineCode",{parentName:"p"},"getId()")," getter method and that will be sent back in the graphql\nresponse.  It does that for every field in the query on that type."),(0,o.kt)("p",null,'By creating a "unified view" at the higher level data fetcher, you have mapped between your runtime view of the data and the graphql schema view of the data.'),(0,o.kt)("h1",{id:"mapping-input-data"},"Mapping input data"),(0,o.kt)("h2",{id:"how-graphql-maps-object-data-to-input-types"},"How graphql maps object data to input types"),(0,o.kt)("p",null,"Input type values are provided to as input to a graphql operation.  The three kinds of types that can be input are ",(0,o.kt)("strong",{parentName:"p"},"Enums"),", ",(0,o.kt)("strong",{parentName:"p"},"Scalars")," and ",(0,o.kt)("strong",{parentName:"p"},"Input Object Types")," and the ",(0,o.kt)("strong",{parentName:"p"},"List")," and ",(0,o.kt)("strong",{parentName:"p"},"Non-Null")," variants of these\ntype kinds."),(0,o.kt)("p",null,"The following outlines how graphql-java represents these type kinds in JVM runtime terms."),(0,o.kt)("h3",{id:"enums"},"Enums"),(0,o.kt)("p",null,"graphql-java maps input ",(0,o.kt)("inlineCode",{parentName:"p"},"Enum")," values by name.  When you create the ",(0,o.kt)("inlineCode",{parentName:"p"},"graphql.schema.GraphQLEnumType")," instance you can in theory map a name ",(0,o.kt)("inlineCode",{parentName:"p"},"java.lang.String"),"\nto any JVM object.  But this is not common at all.  Mostly the name of the enum value is the actual value of it."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-graphql"},"enum RGB {\n    RED, BLUE, GREEN\n}\n\nscalar Pantone\n\ntype Query {\n    toPantone( color : RGB) : Pantone\n}\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"RGB")," enum type above has the runtime JVM ",(0,o.kt)("inlineCode",{parentName:"p"},"java.lang.String")," values of ",(0,o.kt)("inlineCode",{parentName:"p"},'"RED"'),",",(0,o.kt)("inlineCode",{parentName:"p"},'"BLUE"')," and ",(0,o.kt)("inlineCode",{parentName:"p"},'"GREEN"')," on input and output."),(0,o.kt)("p",null,"The graphql-java system allow you to also input ",(0,o.kt)("inlineCode",{parentName:"p"},"java.lang.Enum")," but this is not common at all for input.  The reason it's not common is that this would\nrequire you to turn your network input into Java enums and this is not a common action of serialisation frameworks."),(0,o.kt)("p",null,"If the input value to the enum comes from the graphql operation document, then the input value will initially be a ",(0,o.kt)("inlineCode",{parentName:"p"},"graphql.language.EnumValue")," which\nis the AST representation of a graphql ",(0,o.kt)("inlineCode",{parentName:"p"},"Enum")," value.  This will be converted by graphql-java to a value by name.  "),(0,o.kt)("p",null,"So a query document like the following will end up mapping the AST enum input value ",(0,o.kt)("inlineCode",{parentName:"p"},"RED")," to the JVM value ",(0,o.kt)("inlineCode",{parentName:"p"},'"RED"'),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-graphql"},"query MyColors {\n    toPantone(color : RED)\n}\n")),(0,o.kt)("h3",{id:"scalars"},"Scalars"),(0,o.kt)("p",null,"The input values to a scalar are controlled by the scalar implementation.  If their ",(0,o.kt)("inlineCode",{parentName:"p"},"graphql.schema.Coercing#parseValue(java.lang.Object, graphql.GraphQLContext, java.util.Locale)")," accepts\na certain value then it's up to them to decide what JVM object is returned by the scalar code."),(0,o.kt)("p",null,"The graphql-java scalars will return the following values as JVM object input values."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"String")," aka ",(0,o.kt)("inlineCode",{parentName:"li"},"GraphQLString")," - will produce a ",(0,o.kt)("inlineCode",{parentName:"li"},"java.lang.String")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Boolean")," aka ",(0,o.kt)("inlineCode",{parentName:"li"},"GraphQLBoolean")," - will produce a ",(0,o.kt)("inlineCode",{parentName:"li"},"java.lang.Boolean")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Int")," aka ",(0,o.kt)("inlineCode",{parentName:"li"},"GraphQLInt")," - will produce a ",(0,o.kt)("inlineCode",{parentName:"li"},"java.lang.Integer")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Float")," aka ",(0,o.kt)("inlineCode",{parentName:"li"},"GraphQLFloat")," - will produce a ",(0,o.kt)("inlineCode",{parentName:"li"},"java.lang.Double")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"ID")," aka ",(0,o.kt)("inlineCode",{parentName:"li"},"GraphQLID")," - will produce a ",(0,o.kt)("inlineCode",{parentName:"li"},"java.lang.String"))),(0,o.kt)("h3",{id:"input-object-types"},"Input Object Types"),(0,o.kt)("p",null,"Input object types are complex input types with named input fields. The runtime JVM representation will be a ",(0,o.kt)("inlineCode",{parentName:"p"},"java.util.Map"),".  Specifically\na map that ordered its keys in a predictable way."),(0,o.kt)("p",null,"So imagine this input type named ",(0,o.kt)("inlineCode",{parentName:"p"},"Person")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-graphql"},"input Person {\n    name : String!\n    age : Int!\n}\n\ntype Query {\n    contact(person : Person) : String\n}\n")),(0,o.kt)("p",null,"This will be represented at runtime as a ",(0,o.kt)("inlineCode",{parentName:"p"},"java.util.Map")," containing a key ",(0,o.kt)("inlineCode",{parentName:"p"},"name")," with a ",(0,o.kt)("inlineCode",{parentName:"p"},"java.lang.String")," value and\na key ",(0,o.kt)("inlineCode",{parentName:"p"},"age")," with a ",(0,o.kt)("inlineCode",{parentName:"p"},"java.lang.Integer")," value."),(0,o.kt)("h3",{id:"nonnull-input-types"},"Nonnull input types"),(0,o.kt)("p",null,"There is no special runtime object used for non-null input types other than the called code can safely assume that the object\nis not a null value."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-graphql"},"type Query {\n    field(arg1 : String!, arg2 : String) : String\n}\n")),(0,o.kt)("p",null,"So in the example above the ",(0,o.kt)("inlineCode",{parentName:"p"},"arg1")," field argument will always be a non-null ",(0,o.kt)("inlineCode",{parentName:"p"},"java.lang.String")," value while ",(0,o.kt)("inlineCode",{parentName:"p"},"arg2")," may be ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," at runtime."),(0,o.kt)("h3",{id:"lists-of-input-types"},"Lists of input types"),(0,o.kt)("p",null,"If the input type is a graphql list input type then the runtime JVM representation will be a ",(0,o.kt)("inlineCode",{parentName:"p"},"java.util.List")," of the wrapped input type."),(0,o.kt)("p",null,"So as an example, given"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-graphql"},"type Query {\n    field(arg : [String!]!) : String\n}\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"arg")," field argument would be a non-null ",(0,o.kt)("inlineCode",{parentName:"p"},"java.util.List")," containing zero or more non-null ",(0,o.kt)("inlineCode",{parentName:"p"},"java.lang.String")," values."),(0,o.kt)("p",null,"In graphql you can say that a list is non-null and its entries are also non-null\nhowever there is no way to say that the list has one or more entries.  "),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"arg")," field argument above could be an empty list.  It will not be ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," but it could be empty."),(0,o.kt)("p",null,"Complex runtime input values can be declared and the runtime representation will reflect that."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-graphql"},"input Person {\n    name : String!\n    age : Int!\n    friends : [Person!]\n}\n\ntype Query {\n    contacts(people : [Person!]!) : String\n}\n\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"person")," field argument would be a ",(0,o.kt)("inlineCode",{parentName:"p"},"java.util.List")," containing one or more ",(0,o.kt)("inlineCode",{parentName:"p"},"java.util.Map"),"s, where each map contained named entries\nand the ",(0,o.kt)("inlineCode",{parentName:"p"},"friends")," map entry could itself be a ",(0,o.kt)("inlineCode",{parentName:"p"},"java.util.List")," containing one or more ",(0,o.kt)("inlineCode",{parentName:"p"},"java.util.Map"),"s, so imagine\nthe following representation at runtime :"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'        List.of(\n                Map.of("name", "Brad",\n                        "age", 42,\n                        "friends", List.of(\n                                Map.of("name", "Bill",\n                                        "age", 17,\n                                        "friends", List.of()\n                                )\n                        )\n                ),\n                Map.of("name", "Andreas",\n                        "age", 34,\n                        "friends", List.of(\n                                Map.of("name", "Ted",\n                                        "age", 15,\n                                        "friends", List.of()\n                                )\n                        )\n                )\n        );\n\n')))}d.isMDXComponent=!0}}]);