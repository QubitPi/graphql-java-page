<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://QubitPi.github.io/graphql-java-page/blog</id>
    <title>GraphQL Java Blog</title>
    <updated>2023-03-21T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://QubitPi.github.io/graphql-java-page/blog"/>
    <subtitle>GraphQL Java Blog</subtitle>
    <icon>https://QubitPi.github.io/graphql-java-page/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[GraphQL Java release policy]]></title>
        <id>release-policy</id>
        <link href="https://QubitPi.github.io/graphql-java-page/blog/release-policy"/>
        <updated>2023-03-21T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[We’re formalising our release schedule to give the community a better idea of when to expect releases, what will be contained within them, and when important fixes will be backported.]]></summary>
        <content type="html"><![CDATA[<p>We’re formalising our release schedule to give the community a better idea of when to expect releases, what will be contained within them, and when important fixes will be backported.</p><h2>General release schedule</h2><p>Going forward, we plan to have 4 releases every year, approximately one per quarter. We will alternate between releases containing breaking changes, and releases containing features and bugfixes (without breaking changes).</p><p>For example: our next release 20.1 will be in late March 2023, and this will be a feature and bugfix release without breaking changes. Therefore, we’re going to retain Java 8 in the 20.1 release. Our subsequent quarterly release will be around early July 2023 and will contain breaking changes, including upgrading to Java 11.</p><h2>Security backports</h2><p>We will backport critical bugfixes and security fixes for versions dating back 18 months (or roughly 6 versions). These fixes will be backported depending on severity and demand. As security fixes are time sensitive, we will release them on demand instead of waiting for the next quarterly release date.</p><h2>Bugfix backports</h2><p>We will backport important bug fixes at most 12 months (or roughly 4 versions). These fixes will be backported depending on the severity of the bug and demand.</p><h2>Deprecations</h2><p>When code is deprecated, we will wait at least 12 months before removing it (or roughly 4 versions).</p><h2>Version numbering</h2><p>We will continue to use <code>major.minor</code> version numbering.</p><p>A minor version can include bug fixes and features, but not breaking changes. A major version can include breaking changes.</p><h2>Allowing for policy changes</h2><p>The aim of this release policy to give the community a better indication of release dates, what is contained in releases, and when fixes will be backported. However, we may make a pragmatic decision to diverge from this policy when required. For example, a major and urgent breaking change could result in two breaking change releases in a row. If we diverge from this release policy, we’ll make it clear in the release notes.</p>]]></content>
        <author>
            <name>Donna Zhou</name>
            <uri>https://github.com/dondonz</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[GraphQL Java will require Java 11]]></title>
        <id>java-11-required</id>
        <link href="https://QubitPi.github.io/graphql-java-page/blog/java-11-required"/>
        <updated>2022-12-14T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[GraphQL Java will require Java 11 as a minimum Java version, starting from version 21.]]></summary>
        <content type="html"><![CDATA[<p>GraphQL Java will require Java 11 as a minimum Java version, starting from version 21.</p><p>With Java 8 being released over 8 years ago and Java 17 more than one year ago, we think now is the
right time to upgrade the minimum Java version GraphQL Java is developed against.</p><p>This means starting with version 21 you need to use at least Java 11 to run GraphQL Java.</p><p>Depending on the feedback we get, we plan to release bugfix releases for version 20 for some time, but no longer
than until end of 2023.</p><p>Please discuss and leave feedback <a href="https://github.com/graphql-java/graphql-java/discussions/3052">here</a></p>]]></content>
        <author>
            <name>Andreas Marek</name>
            <uri>https://github.com/andimarek</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Version 20 released]]></title>
        <id>version-20-released</id>
        <link href="https://QubitPi.github.io/graphql-java-page/blog/version-20-released"/>
        <updated>2022-12-07T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[We are pleased to announce the release of graphql-java 20.0!]]></summary>
        <content type="html"><![CDATA[<p>We are pleased to announce the release of graphql-java 20.0!</p><p>Special thanks to each of the 200+ contributors over the years, who have made this milestone possible.</p><p>We&#x27;ve added support for record-like property fetching, added performance improvements for <code>PropertyDataFetcher</code> and reduced object allocation.</p><p>Version 20 also introduces internationalization (i18n) for validation, parsing, and scalar coercion <a href="https://github.com/graphql-java/graphql-java/tree/master/src/main/resources/i18n">error messages</a>. We have added German translations, and we would love to see more languages. If you would like to contribute, please open a pull request.</p><p>See the full release notes on <a href="https://github.com/graphql-java/graphql-java/releases/tag/v20.0">GitHub</a>.</p>]]></content>
        <author>
            <name>Donna Zhou</name>
            <uri>https://github.com/dondonz</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring for GraphQL is the recommended Spring integration]]></title>
        <id>spring-for-graphql</id>
        <link href="https://QubitPi.github.io/graphql-java-page/blog/spring-for-graphql"/>
        <updated>2022-09-20T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[If you are building a GraphQL application with Spring, we recommend using the official Spring for GraphQL integration. This integration is a collaboration between the Spring and GraphQL Java teams, and is maintained by the Spring team. In May 2022, Spring for GraphQL 1.0 GA was released.]]></summary>
        <content type="html"><![CDATA[<p>If you are building a GraphQL application with Spring, we recommend using the official <a href="https://spring.io/projects/spring-graphql">Spring for GraphQL</a> integration. This integration is a collaboration between the Spring and GraphQL Java teams, and is maintained by the Spring team. In May 2022, Spring for GraphQL 1.0 GA was <a href="https://spring.io/blog/2022/05/19/spring-for-graphql-1-0-release">released</a>.</p><p>Use <a href="https://start.spring.io/">Spring Initializr</a> to create a GraphQL application. For a quick tutorial, please see our <a href="https://www.graphql-java.com/tutorials/getting-started-with-spring-boot">Spring for GraphQL tutorial</a>.</p><p>See also the Spring for GraphQL <a href="https://docs.spring.io/spring-graphql/docs/current/reference/html/">documentation</a> and the repo on <a href="https://github.com/spring-projects/spring-graphql">GitHub</a>.</p><p>Before the official Spring for GraphQL integration was released, there were many other GraphQL integrations for Spring, including the similarly named <a href="https://github.com/graphql-java-kickstart/graphql-spring-boot">GraphQL Java Spring</a> project from the GraphQL Java team, published under the <code>com.graphql-java</code> and <code>com.graphql-java-kickstart</code> group IDs. Many tutorials are still referring to this unrelated project.</p><p>Please use the official integration named <strong>&quot;Spring for GraphQL&quot;</strong>, published under <code>org.springframework</code> and related group IDs.</p>]]></content>
        <author>
            <name>Donna Zhou</name>
            <uri>https://github.com/dondonz</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[GraphQL Java 17 released and an update about LTS]]></title>
        <id>17-released-and-lts</id>
        <link href="https://QubitPi.github.io/graphql-java-page/blog/17-released-and-lts"/>
        <updated>2021-08-03T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[We are happy to announce the availability of GraphQL Java 17.0.]]></summary>
        <content type="html"><![CDATA[<p>We are happy to announce the availability of GraphQL Java 17.0.
See <a href="https://github.com/graphql-java/graphql-java/releases/tag/v17.0">17.0 release notes</a> for all the details.</p><p>At the same time we wanted to give an update regarding our LTS (Long Term Support) policy.
Previously we maintained a LTS version of 9.x and after quite some time we announced 14.x as the next LTS.</p><p>The reality is that we didn&#x27;t maintain 14.x really as a LTS version (we only released one bugfix release).
This was mainly caused by the minimal community feedback and our limited time and resources.</p><p>Going forward we decided to no offer any LTS versions anymore. We will only actively maintain and bugfix
the latest version (currently 17). We may backport critical bugfixes, but we are not committed to it.</p><p>If this is a huge problem for you or your Company and you are willing to help us with maintaining a LTS
version you can reach us at Twitter <a href="https://twitter.com/graphql_java">GraphQL Java</a> or per mail at
hello at graphql-java dot com.</p>]]></content>
        <author>
            <name>Andreas Marek</name>
            <uri>https://github.com/andimarek</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[GraphQL spec releases are not important]]></title>
        <id>spec-releases-are-not-important</id>
        <link href="https://QubitPi.github.io/graphql-java-page/blog/spec-releases-are-not-important"/>
        <updated>2021-02-12T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Every once in a while somebody asks which version of the GraphQL spec]]></summary>
        <content type="html"><![CDATA[<p>Every once in a while somebody asks which version of the <a href="https://github.com/graphql/graphql-spec">GraphQL spec</a>
GraphQL Java supports. The general answer is: the current draft.</p><p>The bigger question behind this is: what is the information you want get out of this question?
Why do you ask this question?</p><p>The thing is: spec releases are not really important and people misinterpret what they mean.</p><h1>Evolution of the spec process</h1><p>The GraphQL spec has five releases so far:</p><ul><li>two in 2015 (including the first published version)</li><li>two in 2016</li><li>one in 2018</li></ul><p>As you can see in the first two years spec releases where quite frequently, but after the one in 2018,
there has not been a release.</p><p>2017 was also the year the <a href="https://github.com/graphql/graphql-wg">GraphQL Working Group</a> was established.
This group is the main forum to evolve the spec since then. Over time this group established a very high bar
for every PR to be merged into the spec. (See the <a href="https://github.com/graphql/graphql-spec/blob/main/CONTRIBUTING.md">Contributing guidelines</a>)</p><p>With this high standard set, nearly all implementations (including GraphQL Java) started to implement every
merged PR instead of waiting for a big release. Because they are very confident this change will be released
in this form, it is safe to implement it right away.</p><p>This treatment of merged PRs as de-factor releases is now an established rule in the GraphQL community.
This explains why the whole GraphQL ecosystem has evolved a lot since 2018, even without a release.</p><p><strong>A release is not needed anymore if every merged PR is like a mini release.</strong></p><p>Future releases are more like an
<a href="https://github.com/graphql/graphql-wg/blob/main/notes/2021-02-04.md#promoting-and-documenting-spec-release-5m-brian">opportunity to look back and promote the work since the last release.</a></p><p>I personally hope that we make this de-facto rule, that evey PR is a mini release, more official.
We should not use the word &quot;draft&quot; any more, but every merged PR should automatically result in a
new GraphQL spec version which is formally approved by the <a href="https://github.com/graphql/graphql-wg/blob/main/GraphQL-TSC.md">GraphQL TSC.</a></p><p>Coming back to the question: &quot;Which spec version of GraphQL is supported&quot;?
I hope by now it is clear why this question is probably not really helpful.</p><p>It is better to think about certain features you want to discuss instead referring to the spec releases.</p><h1>Feedback or questions</h1><p>We use <a href="https://github.com/graphql-java/graphql-java/discussions">GitHub Discussions</a> for general feedback and questions.</p><p>You can also contact us on Twitter: <a href="https://twitter.com/graphql_java">@graphql_java</a></p>]]></content>
        <author>
            <name>Andreas Marek</name>
            <uri>https://github.com/andimarek</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[GraphQL Java and Threads]]></title>
        <id>threads</id>
        <link href="https://QubitPi.github.io/graphql-java-page/blog/threads"/>
        <updated>2021-02-05T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[We follow a fundamental rule in GraphQL Java regarding Threads: GraphQL Java never creates]]></summary>
        <content type="html"><![CDATA[<p>We follow a fundamental rule in GraphQL Java regarding Threads: GraphQL Java never creates
Threads or interacts with Thread pools. We do this because we want to give the user the full control
and whatever GraphQL Java would do, it would not be correct for every use case.</p><p>Additionally to being strictly unopinionated regarding Threads, GraphQL Java is also fully reactive,
implemented via <code>CompletableFuture</code> (<code>CF</code>).
These two constrain together mean we rely on the <code>CF</code> returned by the user.
Specifically we piggyback on the <code>CF</code> returned by the <code>DataFetcher</code>
(or other async methods which can be implemented by the user, but we focus here on <code>DataFetcher</code>
as it is by far the most important).</p><pre><code class="language-java">// Pseudo code in GraphQL Java

CompletableFuture&lt;Object&gt; dataFetcherResult = invokeDataFetcher();
dataFetcherResult.thenApply(result -&gt; {
    // in which Thread  where this code happens is controlled by the CF returned
    continueExecutingQuery(result);
});
</code></pre><h1>Blocking DataFetcher</h1><p>Lets assume you are accessing a DB in a blocking way in your <code>DataFetcher</code>:</p><pre><code class="language-java">String get(DataFetchingEnvironment env) {
    return getValueFromDb(env); // blocking the Thread until the value is read from DB
};
</code></pre><p>This is not completely wrong, but not recommend in general as the consequence of this kind of <code>DataFecher</code>
is that GraphQL can&#x27;t execute the query in the most efficient way.</p><p>For example for the following query:</p><pre><code class="language-graphql">{
  dbData1
  dbData2
  dbData3
}
</code></pre><p>If the <code>DataFetcher</code> for these <code>dbData</code> fields don&#x27;t return a <code>CF</code>,
but block the Thread until the data is read, GraphQL Java will not work with maximum efficiency.</p><p>GraphQL Java can invoke the <code>DataFetcher</code> for all three fields in parallel. But if your <code>DataFetcher</code> for
<code>dbData1</code> is blocking, GraphQL Java will also be blocked and only invoke the next <code>DataFetcher</code> once <code>dbData&lt;n&gt;</code>
is finished.
The recommend solution to this problem is offloading your blocking code onto a separate Thread pool
as shown here:</p><pre><code class="language-java">CompletableFuture&lt;String&gt; get(DataFetchingEnvironment env) {
    return CompletableFuture.supplyAsync( getValueFromDb(env), dbThreadPool );
};
</code></pre><p>This code will maximize the performance and will cause all three fields to be fetched in parallel.</p><h1>Different pools for different work</h1><p>The subsequent work done by GraphQL Java will be executed in the same <code>dbThreadPool</code> until it
encounters a new <code>DataFetcher</code> returned by the user code and this new <code>CF</code> dedicates the Thread
for the subsequent work.</p><p>If you want to have separate pools for different kind of work, one for the actual <code>DataFetcher</code> which normally
involve IO and one of the actual GraphQL Java work (which is pure CPU), you need to switch back from your offloaded
pool to a dedicated GraphQL Java pool before returning the <code>CF</code>. You can achieve this with code like this:</p><pre><code class="language-java">CompletableFuture&lt;String&gt; get(DataFetchingEnvironment env) {
    return CompletableFuture.supplyAsync( getValueFromDb(env), dbThreadPool )
        .handleAsync((result,exception) -&gt; {
            if(exception !=null) throw exception;
            return result;
        }, graphqlJavaPool);
};
</code></pre><p>Notice the <code>.handleAsync</code> which doesn&#x27;t do anything except forwarding the result, but on a
different pool (<code>graphqlJavaPool</code>).</p><p>This way you have different pools for different kind of work (one for CPU bound GraphQL Java work and one
for multiple ones for IO bound work), which can be configured and monitored independently.</p><h1>In a fully reactive system</h1><p>If your system is fully reactive your <code>DataFetcher</code> will more look like this</p><pre><code class="language-java">CompletableFuture&lt;String&gt; get(DataFetchingEnvironment env) {
    return callAnotherServiceNonBlocking(env); // returns CompletableFuture
};
</code></pre><p>The code above could be implemented via <a href="https://github.com/AsyncHttpClient/async-http-client">Async Http Client</a>
or <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-client">WebFlux WebClient</a>.
Both provide fully reactive HTTP clients.</p><p>Because the code is non blocking there is no need to offload anything on a dedicated Thread pool to avoid blocking
GraphQL Java.</p><p>You still might want to consider using a dedicated GraphQL Java pool as you otherwise would use
Threads which are dedicated to IO. How much this is really relevant depends highly on your use case.</p><p>For example <code>Async Http Client</code> (<code>AHC</code>) uses by default 2 * #cores (this value comes actually from Netty) Threads. If you
don&#x27;t use a dedicated Thread Pool for GraphQL Java you might encounter situations under load where all <code>AHC</code>
Threads are either busy or blocked by GraphQL Java code and as a result your system is not as performant as it
could be. Normally only load tests in production like environments can show the relevance of different Thread pools.</p><h1>Feedback or questions</h1><p>We use <a href="https://github.com/graphql-java/graphql-java/discussions">GitHub Discussions</a> for general feedback and questions.</p>]]></content>
        <author>
            <name>Andreas Marek</name>
            <uri>https://github.com/andimarek</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Building efficient data fetchers by looking ahead]]></title>
        <id>deep-dive-data-fetcher-results</id>
        <link href="https://QubitPi.github.io/graphql-java-page/blog/deep-dive-data-fetcher-results"/>
        <updated>2019-04-11T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Today we are looking into the graphql.schema.DataFetchingFieldSelectionSet and graphql.execution.DataFetcherResult objects as means]]></summary>
        <content type="html"><![CDATA[<p>Today we are looking into the <code>graphql.schema.DataFetchingFieldSelectionSet</code> and <code>graphql.execution.DataFetcherResult</code> objects as means
to build efficient data fetchers.</p><h1>The scenario</h1><p>But first lets set the scene. Imagine we have a system that can return <code>issues</code> and the <code>comments</code> on those <code>issues</code></p><pre><code class="language-graphql">{
  issues {
    key
    summary
    comments {
        text
    }
  }
}
</code></pre><p>Nominally we would have a <code>graphql.schema.DataFetcher</code> on <code>issues</code> that returns a list of issues and one on the field <code>comments</code> that returns the list of comments
for each issue <code>source</code> object.</p><p>As you can see this naively creates an <em>N+1 problem</em> where we need to fetch data multiple times, one for each <code>issue</code> object in isolation.</p><p>We could attack this using the <code>org.dataloader.DataLoader</code> pattern but there is another way which will discuss in this article.</p><h1>Look ahead via DataFetchingFieldSelectionSet</h1><p>The data fetcher behind the <code>issues</code> field is able to look ahead and see what sub fields are being asked for.  In this case it knows that <code>comments</code> are being asked
for and hence it could prefetch them at the same time.</p><p><code>graphql.schema.DataFetchingEnvironment#getSelectionSet</code> (aka <code>graphql.schema.DataFetchingFieldSelectionSet</code>) can be used by data fetcher code to get the selection set of fields for a given parent field.</p><pre><code class="language-java">DataFetcher issueDataFetcher = environment -&gt; {
    DataFetchingFieldSelectionSet selectionSet = environment.getSelectionSet();
    if (selectionSet.contains(&quot;comments&quot;)) {
        List&lt;IssueAndCommentsDTO&gt; data = getAllIssuesWithComments(environment, selectionSet.getFields());
        return data;
    } else {
        List&lt;IssueDTO&gt; issues = getAllIssuesWitNoComments(environment);
        return issues;
    }
};
</code></pre><p>Imagine this is backed by an SQL system we might be able to use this field look ahead to produce the following SQL</p><pre><code class="language-sql">SELECT Issues.Key, Issues.Summary, Comments.Text
FROM Issues
INNER JOIN Comments ON Issues.CommentID=Comments.ID;
</code></pre><p>So we have looked ahead and returned different data depending on the field sub selection.  We have made our system more efficient by using look ahead
to fetch data just the <code>1</code> time and not <code>N+1</code> times.</p><h1>Code Challenges</h1><p>The challenge with this code design is that the shapes of the returned data is now field sub selection specific.  We needed a <code>IssueAndCommentsDTO</code> for one sub selection
path and a simpler <code>IssueDTO</code> for another path.</p><p>With enough paths this becomes problematic as it adds new DTO classes per path and makes out child data fetchers more complex</p><p>Also the standard graphql pattern is that the returned object becomes the <code>source</code> ie. <code>graphql.schema.DataFetchingEnvironment#getSource</code> of the next child
data fetcher.  But we might have pre fetched data that is needed 2 levels deep and this is challenging to do since each data fetcher would need to capture and copy
that data down to the layers below via new TDOs classes per level.</p><h1>Passing Data and Local Context</h1><p>GraphQL Java offers a capability that helps with this pattern.  GraphQL Java goes beyond what the reference graphql-js system gives you where the object you
returned is automatically the <code>source</code> of the next child fetcher and that&#x27;s all it can be.</p><p>In GraphQL Java you can use well known <code>graphql.execution.DataFetcherResult</code> to return three sets of values</p><ul><li><code>data</code>  - which will be used as the source on the next set of sub fields</li><li><code>errors</code> - allowing you to return data as well as errors</li><li><code>localContext</code> - which allows you to pass down field specific context</li></ul><p>When the engine sees the <code>graphql.execution.DataFetcherResult</code> object, it automatically unpacks it and handles it three classes of data in specific ways.</p><p>In our example case we will be use <code>data</code> and <code>localContext</code> to communicate between fields easily.</p><pre><code class="language-java">DataFetcher issueDataFetcher = environment -&gt; {
    DataFetchingFieldSelectionSet selectionSet = environment.getSelectionSet();
    if (selectionSet.contains(&quot;comments&quot;)) {
        List&lt;IssueAndCommentsDTO&gt; data = getAllIssuesWithComments(environment, selectionSet.getFields());

        List&lt;IssueDTO&gt; issues = data.stream().map(dto -&gt; dto.getIssue()).collect(toList());

        Map&lt;IssueDTO, List&lt;CommentDTO&gt;&gt; preFetchedComments = mkMapOfComments(data);

        return DataFetcherResult.newResult()
                .data(issues)
                .localContext(preFetchedComments)
                .build();
    } else {
        List&lt;IssueDTO&gt; issues = getAllIssuesWitNoComments(environment);
        return DataFetcherResult.newResult()
                .data(issues)
                .build();
    }
};
</code></pre><p>If you look now you will see that our data fetcher returns a <code>DataFetcherResult</code> object that contains <code>data</code> for the child data fetchers which is the
list of <code>issueDTO</code> objects as per usual.  It will be their <code>source</code> object when they run.</p><p>It also passes down field specific <code>localContext</code> which is the pre-fetched comment data.</p><p>Unlike the global context object, local context objects are passed down from a specific field to its children and are not shared across to peer fields.  This means
a parent field has a &quot;back channel&quot; to talk to the child fields without having to &quot;pollute&quot; the DTO source objects with that information and it is &quot;local&quot; in the sense
that it given only to this field and its children and not any other field in the query.</p><p>Now lets look at the <code>comments</code> data fetcher and how it consumes this back channel of data</p><pre><code class="language-java">DataFetcher commentsDataFetcher = environment -&gt; {
    IssueDTO issueDTO = environment.getSource();
    Map&lt;IssueDTO, List&lt;CommentDTO&gt;&gt; preFetchedComments = environment.getLocalContext();
    List&lt;CommentDTO&gt; commentDTOS = preFetchedComments.get(issueDTO);
    return DataFetcherResult.newResult()
            .data(commentDTOS)
            .localContext(preFetchedComments)
            .build();
};
</code></pre><p>Notice how it got the <code>issueDTO</code> as its source object as expected but it also got a local context object which is our pre-fetched comments.  It can choose
to pass on new local context OR if it passes nothing then the previous value will bubble down to the next lot of child fields.  So you can think of <code>localContext</code>
as being inherited unless a fields data fetcher explicitly overrides it.</p><p>Our data fetcher is a bit more complex because of the data pre-fetching but &#x27;localContext&#x27; allows us a nice back channel to pass data without modifying our DTO objects
that are being used in more simple data fetchers.</p><h1>Passing back Errors or Data or Both</h1><p>For completeness we will show you that you can also pass down errors or data or local context or all of them at once.</p><p>It is perfectly valid to fetch data in graphql and to ALSO send back errors.  Its not common but its valid. Some data is better than no data.</p><pre><code class="language-java">GraphQLError error = mkSpecialError(&quot;Its Tuesday&quot;);

return DataFetcherResult.newResult()
        .data(commentDTOS)
        .error(error)
        .build();
</code></pre>]]></content>
        <author>
            <name>Brad Baker</name>
            <uri>https://github.com/bbakerman</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[GraphQL Deep Dive Part 1 - merged fields]]></title>
        <id>deep-dive-merged-fields</id>
        <link href="https://QubitPi.github.io/graphql-java-page/blog/deep-dive-merged-fields"/>
        <updated>2019-01-22T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Welcome to the new series "GraphQL deep dive" where we will explore advanced or unknown GraphQL topics. The plan is to discuss things mostly in a language and implementation neutral way, even if it is hosted on graphql-java.com.]]></summary>
        <content type="html"><![CDATA[<p>Welcome to the new series &quot;GraphQL deep dive&quot; where we will explore advanced or unknown GraphQL topics. The plan is to discuss things mostly in a language and implementation neutral way, even if it is hosted on graphql-java.com.</p><h1>Merged Fields</h1><p>First thing we are looking at is &quot;merged fields&quot;.</p><p>GraphQL allows for a field to be declared multiple times in a query as long as it can be merged.</p><p>Valid GraphQL queries are:</p><pre><code class="language-graphql">{
  foo
  foo
}
</code></pre><pre><code class="language-graphql">{
  foo(id: &quot;123&quot;)
  foo(id: &quot;123&quot;)
  foo(id: &quot;123&quot;)
}
</code></pre><pre><code class="language-graphql">{
  foo(id: &quot;123&quot;) {
    id
  }
  foo(id: &quot;123&quot;) {
    name
  }
  foo(id: &quot;123&quot;) {
    id
    name
  }
}
</code></pre><p>Each of these queries will result in a result with just one &quot;foo&quot; key, not two or three.</p><p>Invalid Queries are:</p><pre><code class="language-graphql">{
  foo
  foo(id: &quot;123&quot;)
}
</code></pre><pre><code class="language-graphql">{
  foo(id: &quot;123&quot;)
  foo(id: &quot;456&quot;, id2: &quot;123&quot;)
}
</code></pre><pre><code class="language-graphql">{
  foo(id: &quot;123&quot;)
  foo: foo2
}
</code></pre><p>The reason why they are not valid, is because the fields are different: in the first two examples the arguments differ and the third query actually has two different fields under the same key.</p><h1>Motivation</h1><p>The examples so far don&#x27;t seem really useful, but it all makes sense when you add fragments:</p><pre><code class="language-graphql">{
  ...myFragment1
  ...myFragment2
}

fragment myFragment1 on Query {
  foo(id: &quot;123&quot;) {
    name
  }
}
fragment myFragment2 on Query {
  foo(id: &quot;123&quot;) {
    url
  }
}

</code></pre><p>Fragments are designed to be written by different parties (for example different components in a UI) which should not know anything about each other. Requiring that every field can only be declared once would make this objective unfeasible.</p><p>But by allowing fields merging, as long as the fields are the same, allows fragments to be authored in an independent way from each other.</p><h1>Rules when fields can be merged</h1><p>The specific details when fields can be merged are written down in <a href="https://facebook.github.io/graphql/draft/#sec-Field-Selection-Merging">Field Selection Merging</a> in the spec.</p><p>The rules are what you would expect in general and they basically say that fields must be the same. The following examples are taken from the spec and they are all valid:</p><pre><code class="language-graphql">fragment mergeIdenticalFields on Dog {
  name
  name
}
fragment mergeIdenticalAliasesAndFields on Dog {
  otherName: name
  otherName: name
}
fragment mergeIdenticalFieldsWithIdenticalArgs on Dog {
  doesKnowCommand(dogCommand: SIT)
  doesKnowCommand(dogCommand: SIT)
}
fragment mergeIdenticalFieldsWithIdenticalValues on Dog {
  doesKnowCommand(dogCommand: $dogCommand)
  doesKnowCommand(dogCommand: $dogCommand)
}
</code></pre><p>The most complex case happens when you have fields in fragments on different types:</p><pre><code class="language-graphql">fragment safeDifferingFields on Pet {
  ... on Dog {
    volume: barkVolume
  }
  ... on Cat {
    volume: meowVolume
  }
}
</code></pre><p>This is normally invalid because <code>volume</code> is an alias for two different fields <code>barkVolume</code> and <code>meowVolume</code> but because only one of the some are actually resolved and they both return a value of the same type (we assume here that <code>barkVolume</code> and <code>meowVolume</code> are both of the same type) it is valid.</p><pre><code class="language-graphql">fragment safeDifferingArgs on Pet {
  ... on Dog {
    doesKnowCommand(dogCommand: SIT)
  }
  ... on Cat {
    doesKnowCommand(catCommand: JUMP)
  }
}
</code></pre><p>This is again a valid case because even if the first <code>doesKnowCommand</code> has a different argument than the second <code>doesKnowCommand</code> only one of them is actually resolved.</p><p>In the next example <code>someValue</code> has different types (we assume that <code>nickname</code> is a <code>String</code> and <code>meowVolume</code> is a <code>Int</code>) and therefore the query is not valid:</p><pre><code class="language-graphql">fragment conflictingDifferingResponses on Pet {
  ... on Dog {
    someValue: nickname
  }
  ... on Cat {
    someValue: meowVolume
  }
}
</code></pre><h1>Sub selections and directives</h1><p>One thing to keep in my mind is that the sub selections of fields are merged together. For example here <code>foo</code> is resolved once and than <code>id</code> and <code>name</code> is resolved.</p><pre><code class="language-graphql">{
  foo(id: &quot;123&quot;) {
    id
  }
  foo(id: &quot;123&quot;) {
    name
  }
}
</code></pre><p>This query is the same as:</p><pre><code class="language-graphql">{
  foo(id: &quot;123&quot;) {
    id
    name
  }
}
</code></pre><p>The second thing to keep in mind is that different directives can be on each field:</p><pre><code class="language-graphql">{
  foo(id: &quot;123&quot;) @myDirective {
    id
  }
  foo(id: &quot;123&quot;) @myOtherDirective {
    name
  }
}
</code></pre><p>So if you want to know all directives for the current field you are resolving you actually need to look at all of the merged fields from the query.</p><h1>Merged fields in graphql-js and GraphQL Java</h1><p>In graphql-js merged fields are relevant when you implement a resolver and you need access to the specific ast field of the query. The <code>info</code> objects has a property <code>fieldNodes</code> which gives you access to all ast fields which are merged together.</p><p>In GraphQL Java depending on the version you are running you have <code>List&lt;Field&gt; getFields()</code> in the <code>DataFetcherEnvironment</code> or for GraphQL Java newer than <code>12.0</code> you have also <code>MergedField getMergedField()</code> which is the recommend way to access all merged fields.</p>]]></content>
        <author>
            <name>Andreas Marek</name>
            <uri>https://github.com/andimarek</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[First release of GraphQL Java Spring]]></title>
        <id>graphql-java-spring-support</id>
        <link href="https://QubitPi.github.io/graphql-java-page/blog/graphql-java-spring-support"/>
        <updated>2018-12-01T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Spring for GraphQL is the official and current Spring integration. The integration is a collaboration between the Spring and GraphQL Java teams, and is maintained by the Spring team.]]></summary>
        <content type="html"><![CDATA[<p>:::caution
<strong><a href="https://spring.io/projects/spring-graphql">Spring for GraphQL</a> is the official and current Spring integration.</strong> The integration is a collaboration between the Spring and GraphQL Java teams, and is maintained by the Spring team. </p><p><a href="https://www.graphql-java.com/blog/spring-for-graphql">We recommend using Spring for GraphQL</a>, rather than the older Spring project mentioned in this blog post.</p><p>See our <a href="https://www.graphql-java.com/tutorials/getting-started-with-spring-boot">Spring for GraphQL</a> tutorial for how to get started.
:::</p><p>We are happy to release the first version of the GraphQL Java Spring (Boot) project.</p><p>As <a href="https://www.graphql-java.com/blog/graphql-java-aims-to-be-used-directly/">described before</a> this project
complements the GraphQL Java core project if you build a fully operational GraphQL server with Spring.</p><p>Currently it supports GET and POST requests and allows for some basic customization.</p><p>In future we are looking into supporting more advanced features like file upload or subscriptions.</p><p>As always contributions are more than welcome and we are hoping to grow this project together with the
community: please open a <a href="https://github.com/graphql-java/graphql-java-spring/issues/new">new issue</a> or leave a comment on <a href="https://spectrum.chat/graphql-java">spectrum chat</a> about your wishes.</p><p>More details on how to use it can be found on the github page: <a href="https://github.com/graphql-java/graphql-java-spring">https://github.com/graphql-java/graphql-java-spring</a></p>]]></content>
        <author>
            <name>Andreas Marek</name>
            <uri>https://github.com/andimarek</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Introducing graphql-java-extended-scalars]]></title>
        <id>introducing-extended-scalars</id>
        <link href="https://QubitPi.github.io/graphql-java-page/blog/introducing-extended-scalars"/>
        <updated>2018-11-24T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[One of the most common questions we get in GraphQL Java land is "can we have a datetime scalar".]]></summary>
        <content type="html"><![CDATA[<p>One of the most common questions we get in GraphQL Java land is &quot;can we have a datetime scalar&quot;.</p><p>This is not defined by the graphql specification per se so we are reluctant to add it to the core library and then have it turn
up later as an officially specified type.</p><p>But it really is a badly needed type in your GraphQL arsenal and hence <code>graphql-java-extended-scalars</code> was born</p><p><a href="https://github.com/graphql-java/graphql-java-extended-scalars">https://github.com/graphql-java/graphql-java-extended-scalars</a></p><p>This will be a place where we can add non standard but useful extensions to GraphQL Java.</p><p>The major scalars we have added on day one are</p><ul><li><p>The aforementioned DateTime scalar as well as a Date and Time scalar</p></li><li><p>A Object scalar or sometimes know as a JSON scalar that allows a map of values to be returned as a scalar value</p></li><li><p>Some numeric scalars that constrain the values allowed such as <code>PositiveInt</code></p></li><li><p>A Regex scalar that allows a string to fit a regular expression</p></li><li><p>A Url scalar that produces <code>java.net.URL</code> objects at runtime</p></li><li><p>And finally an aliasing technique that allows you to create more meaningfully named scalar values</p><p>We hope you find them useful.</p></li></ul><p>Cheers,</p><p>Brad</p>]]></content>
        <author>
            <name>Brad Baker</name>
            <uri>https://github.com/bbakerman</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[GraphQL Java aims to be used directly]]></title>
        <id>graphql-java-aims-to-be-used-directly</id>
        <link href="https://QubitPi.github.io/graphql-java-page/blog/graphql-java-aims-to-be-used-directly"/>
        <updated>2018-11-10T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[There seems to be a common misconception about GraphQL Java: that you should not use it directly,]]></summary>
        <content type="html"><![CDATA[<p>There seems to be a common misconception about GraphQL Java: that you should not use it directly,
but rather use another library build on top of it.</p><p>We think it is important to make it clear, that this is not the case: GraphQL Java aims to be a library used directly
without any additionally abstraction on top. It was always build with this goal in mind.</p><p>To be fair: we didn&#x27;t do a very good job so far to make that clear. For example up
<a href="https://www.graphql-java.com/blog/moving-projects/">until recently</a> we hosted several other projects which
provided abstractions on top of GraphQL Java. This was because of historical reasons and we didn&#x27;t give any
guidance on when to use what. There are also currently more tutorials out there which don&#x27;t use GraphQL Java directly
compared to tutorials which do.</p><p>The other reason people might think that GraphQL Java is not suitable is because the <a href="https://github.com/graphql-java/graphql-java">core project</a>
doesn&#x27;t provide any easy way to get a full service with HTTP endpoint up and running.
And the existing third party projects providing for example Spring Boot support
are adding abstractions.</p><p>The core project doesn&#x27;t deal with any form of HTTP or JSON specific things and has on purpose basically no
dependencies at all. This will not change, but we recognize the need for having an easy way to get a
full service up and running. This is why we are currently working on first class Spring (Boot) support.</p><p>This is not done yet, but it will provide an easy way to integrate GraphQL Java in a Spring (Boot) application
without adding any abstraction on top of GraphQL Java. It will also be extended over time with more advanced features
like Apollo Defer support.</p><p>To recap:</p><ol><li>GraphQL Java aims to be a first class library used directly</li><li>The <a href="https://github.com/graphql-java/graphql-java">GraphQL Java core project</a> doesn&#x27;t deal with HTTP/JSON and will continue not do it</li><li>The <a href="https://github.com/graphql-java/graphql-java-spring">GraphQL Java Spring project</a> will complement
the core project in providing comprehensive Spring (Boot) support</li></ol><p>Cheers,</p><p>Andi</p>]]></content>
        <author>
            <name>Andreas Marek</name>
            <uri>https://github.com/andimarek</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[About breaking changes and Long-term support]]></title>
        <id>breaking-changes-and-lts</id>
        <link href="https://QubitPi.github.io/graphql-java-page/blog/breaking-changes-and-lts"/>
        <updated>2018-10-20T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[We are releasing new major versions of GraphQL Java roughly every 2 months. They are major versions because we break the API in it. We do it regularly and we prioritize clean code including good naming and design very high. Actually higher than API stability.]]></summary>
        <content type="html"><![CDATA[<p>We are releasing new major versions of GraphQL Java roughly every 2 months. They are major versions because we break the API in it. We do it regularly and we prioritize clean code including good naming and design very high. Actually higher than API stability.</p><p>We do that because we are optimizing for long-term growth: GraphQL Java is 3 1/2 years old and it is just getting started. This means more people will be positively affected from a better experience compared to the ones who need to refactor.</p><p>We do it also because of resource constraints: we are an open source private run project with limited time and resources. We can’t afford maintaining a badly designed project in the long-term. Every bad design, every bad naming makes adding features and adopting to new requirements harder, more time consuming and more unlikely. We also want to make external contributions as easy as possible because we can’t do it all ourself.</p><p>The last reason is personal and it is about fun. I don’t wanna maintain a badly designed project. I need to have fun if I wanna continue to invest a large amount of private time in GraphQL Java.</p><p>Does that mean we just refactor as crazy and break everything all the time? No it doesn’t. We follow some rules about breaking changes:</p><ul><li><p>We never take a functionality away. We deprecate things and make it clear that we don’t really support them anymore, but we don’t take them away without a clear alternative.</p></li><li><p>We try to favor simple breaking changes the compiler will catch. For example renaming a method is such a simple change.</p></li><li><p>We try to document in our release notes every breaking change clearly.</p></li><li><p>Even if we prioritize clean design higher than API stability in general we always weigh the benefits of the change vs the cost of adapting to it. There is no hard rule to that, but we always ask: is it worth it?</p></li></ul><p>But  we understand that not every Organization allows for regular updating major versions of GraphQL Java. This is why we started to maintain a Long-term support (LTS) version of GraphQL Java: 9.x. We will continue to back port all bug fixes to 9.x for some time and we will announce when we will switch to a new LTS version.</p><p>It is not clear yet how long this time span will be and it depends also on your feedback. <strong>Please contribute to this <a href="https://spectrum.chat/thread/196ab67d-2770-4f3f-b1b3-b056ecb3a2e1">spectrum thread</a> and let us know what suits you best.</strong> If you have special needs and you don’t wanna discuss it in public you can also reach us via <a href="https://www.graphql-java.com/contact/">contact form</a>.</p><p>Cheers,</p><p>Andi</p>]]></content>
        <author>
            <name>Andreas Marek</name>
            <uri>https://github.com/andimarek</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Moving to spectrum and new documentation home]]></title>
        <id>spectrum-and-new-doc</id>
        <link href="https://QubitPi.github.io/graphql-java-page/blog/spectrum-and-new-doc"/>
        <updated>2018-10-10T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[We have two exciting changes to announce:]]></summary>
        <content type="html"><![CDATA[<p>We have two exciting changes to announce:</p><h1>New support channel at spectrum</h1><p>We are moving our support channel from <a href="https://gitter.im/graphql-java/graphql-java">gitter</a> to <a href="https://spectrum.chat/graphql-java">spectrum</a>. Gitter served us well over the years, but with more and more people using GraphQL Java we are looking for better ways to support our community and we think spectrum is the right place to do that. Especially the Threads oriented view compared to one chat room is something we are looking forward to.</p><p>Please ask new questions at <a href="https://spectrum.chat/graphql-java">https://spectrum.chat/graphql-java</a>. We will stop answering questions in the gitter room and direct people to spectrum. The gitter room will be closed in a couple of weeks.</p><h1>New documentation home</h1><p>We are also moving our documentation from <a href="https://graphql-java.readthedocs.io">readthedocs</a> to our own page at <a href="https://www.graphql-java.com/documentation/">graphql-java.com/documentation</a>.</p><p>While the the new documentation is currently similar to the old one the layout is already an improvement and code examples are much easier readable than before. We are planning more improvements over time.</p><p>Cheers,</p><p>Andi</p>]]></content>
        <author>
            <name>Andreas Marek</name>
            <uri>https://github.com/andimarek</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Moving projects out of the GraphQL Java org]]></title>
        <id>moving-projects</id>
        <link href="https://QubitPi.github.io/graphql-java-page/blog/moving-projects"/>
        <updated>2018-10-02T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Soon after I started started GraphQL Java (almost 3 1/2 years ago) other people started building libraries on top of it. I was happy to welcome them into the GraphQL Java Github organization, because it was great to see the GraphQL Java ecosystem grew and centralizing these projects into one org made sense.]]></summary>
        <content type="html"><![CDATA[<p>Soon after I started started GraphQL Java (almost 3 1/2 years ago) other people started building libraries on top of it. I was happy to welcome them into the <a href="https://github.com/graphql-java/">GraphQL Java Github organization</a>, because it was great to see the GraphQL Java ecosystem grew and centralizing these projects into one org made sense.</p><p>Fast forward to today: the core library <a href="https://github.com/graphql-java/graphql-java">graphql-java</a> is maintained by myself and my co-maintainer Brad, but we are not involved in <code>graphql-spring-boot</code> and other projects. They are independently released and organized without any involvement from us. This leads to confusion from our users and makes it hard to recognize what actually the Graphql Java project is and what are libraries build on top without any involvement from Graphql Java.</p><p>In order to clear up this confusion we have decided to move these projects or to archive them:</p><ul><li><code>graphql-spring-boot</code> is moved to <a href="https://github.com/graphql-java-kickstart/graphql-spring-boot">https://github.com/graphql-java-kickstart/graphql-spring-boot</a></li><li><code>graphql-java-tools</code> is moved to <a href="https://github.com/graphql-java-kickstart/graphql-java-tools">https://github.com/graphql-java-kickstart/graphql-java-tools</a></li><li><code>graphql-java-servlet</code> is moved to <a href="https://github.com/graphql-java-kickstart/graphql-java-servlet">https://github.com/graphql-java-kickstart/graphql-java-servlet</a></li><li><code>graphql-java-annotations</code> is moved to <a href="https://github.com/Enigmatis/graphql-java-annotations">https://github.com/Enigmatis/graphql-java-annotations</a></li><li><code>graphql-java-type-generator</code> is archived and  in read only mode: <a href="https://github.com/graphql-java/graphql-java-type-generator/">https://github.com/graphql-java/graphql-java-type-generator/</a></li></ul><p>I wanna make clear that these projects are valuable and successful projects and moving them out of the GraphQL Java Github organization is done to reduce confusion as described above.</p><p>Cheers,</p><p>Andi</p>]]></content>
        <author>
            <name>Andreas Marek</name>
            <uri>https://github.com/andimarek</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Welcome to the new GraphQL Java homepage]]></title>
        <id>welcome-to-graphql-java</id>
        <link href="https://QubitPi.github.io/graphql-java-page/blog/welcome-to-graphql-java"/>
        <updated>2018-10-01T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Welcome to the new GraphQL Java Homepage: the central page about everything GraphQL Java.]]></summary>
        <content type="html"><![CDATA[<p>Welcome to the new GraphQL Java Homepage: the central page about everything GraphQL Java.</p><p>It is still a work in progress and we will continue improving this page over time.</p><p>Cheers,</p><p>Andi</p>]]></content>
        <author>
            <name>Andreas Marek</name>
            <uri>https://github.com/andimarek</uri>
        </author>
    </entry>
</feed>